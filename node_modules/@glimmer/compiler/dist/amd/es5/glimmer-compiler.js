define('@glimmer/compiler', ['exports', '@glimmer/syntax', '@glimmer/util', '@glimmer/wire-format'], function (exports, syntax, util, wireFormat) { 'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolTable = function () {
    function SymbolTable() {
        _classCallCheck$1(this, SymbolTable);
    }

    SymbolTable.top = function top() {
        return new ProgramSymbolTable();
    };

    SymbolTable.prototype.child = function child(locals) {
        var _this = this;

        var symbols = locals.map(function (name) {
            return _this.allocate(name);
        });
        return new BlockSymbolTable(this, locals, symbols);
    };

    return SymbolTable;
}();
var ProgramSymbolTable = function (_SymbolTable) {
    _inherits(ProgramSymbolTable, _SymbolTable);

    function ProgramSymbolTable() {
        _classCallCheck$1(this, ProgramSymbolTable);

        var _this2 = _possibleConstructorReturn(this, _SymbolTable.apply(this, arguments));

        _this2.symbols = [];
        _this2.size = 1;
        _this2.named = util.dict();
        _this2.blocks = util.dict();
        return _this2;
    }

    ProgramSymbolTable.prototype.has = function has(_name) {
        return false;
    };

    ProgramSymbolTable.prototype.get = function get(_name) {
        throw util.unreachable();
    };

    ProgramSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        return {};
    };

    ProgramSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        return [];
    };

    ProgramSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        var named = this.named[name];
        if (!named) {
            named = this.named[name] = this.allocate(name);
        }
        return named;
    };

    ProgramSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        var block = this.blocks[name];
        if (!block) {
            block = this.blocks[name] = this.allocate('&' + name);
        }
        return block;
    };

    ProgramSymbolTable.prototype.allocate = function allocate(identifier) {
        this.symbols.push(identifier);
        return this.size++;
    };

    return ProgramSymbolTable;
}(SymbolTable);
var BlockSymbolTable = function (_SymbolTable2) {
    _inherits(BlockSymbolTable, _SymbolTable2);

    function BlockSymbolTable(parent, symbols, slots) {
        _classCallCheck$1(this, BlockSymbolTable);

        var _this3 = _possibleConstructorReturn(this, _SymbolTable2.call(this));

        _this3.parent = parent;
        _this3.symbols = symbols;
        _this3.slots = slots;
        return _this3;
    }

    BlockSymbolTable.prototype.has = function has(name) {
        return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
    };

    BlockSymbolTable.prototype.get = function get(name) {
        var slot = this.symbols.indexOf(name);
        return slot === -1 ? this.parent.get(name) : this.slots[slot];
    };

    BlockSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        var _this4 = this;

        var dict$$1 = this.parent.getLocalsMap();
        this.symbols.forEach(function (symbol) {
            return dict$$1[symbol] = _this4.get(symbol);
        });
        return dict$$1;
    };

    BlockSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        var locals = this.getLocalsMap();
        return Object.keys(locals).map(function (symbol) {
            return locals[symbol];
        });
    };

    BlockSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        return this.parent.allocateNamed(name);
    };

    BlockSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        return this.parent.allocateBlock(name);
    };

    BlockSymbolTable.prototype.allocate = function allocate(identifier) {
        return this.parent.allocate(identifier);
    };

    return BlockSymbolTable;
}(SymbolTable);
/**
 * Takes in an AST and outputs a list of actions to be consumed
 * by a compiler. For example, the template
 *
 *     foo{{bar}}<div>baz</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 3]],
 *      ['mustache', [mustacheNode, 1, 3]],
 *      ['openElement', [elementNode, 2, 3, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['closeElement', [elementNode, 2, 3],
 *      ['endProgram', [programNode]]]
 *
 * This visitor walks the AST depth first and backwards. As
 * a result the bottom-most child template will appear at the
 * top of the actions list whereas the root template will appear
 * at the bottom of the list. For example,
 *
 *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 2, 0]],
 *      ['openElement', [elementNode, 1, 2, 0]],
 *      ['closeElement', [elementNode, 1, 2]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 2]],
 *      ['openElement', [elementNode, 0, 1, 1]],
 *      ['block', [blockNode, 0, 1]],
 *      ['closeElement', [elementNode, 0, 1]],
 *      ['endProgram', [programNode]]]
 *
 * The state of the traversal is maintained by a stack of frames.
 * Whenever a node with children is entered (either a ProgramNode
 * or an ElementNode) a frame is pushed onto the stack. The frame
 * contains information about the state of the traversal of that
 * node. For example,
 *
 *   - index of the current child node being visited
 *   - the number of mustaches contained within its child nodes
 *   - the list of actions generated by its child nodes
 */

var Frame = function Frame() {
    _classCallCheck$1(this, Frame);

    this.parentNode = null;
    this.children = null;
    this.childIndex = null;
    this.childCount = null;
    this.childTemplateCount = 0;
    this.mustacheCount = 0;
    this.actions = [];
    this.blankChildTextNodes = null;
    this.symbols = null;
};

var TemplateVisitor = function () {
    function TemplateVisitor() {
        _classCallCheck$1(this, TemplateVisitor);

        this.frameStack = [];
        this.actions = [];
        this.programDepth = -1;
    }

    TemplateVisitor.prototype.visit = function visit(node) {
        this[node.type](node);
    };
    // Traversal methods


    TemplateVisitor.prototype.Program = function Program(program) {
        var _actions;

        this.programDepth++;
        var parentFrame = this.getCurrentFrame();
        var programFrame = this.pushFrame();
        if (!parentFrame) {
            program['symbols'] = SymbolTable.top();
        } else {
            program['symbols'] = parentFrame.symbols.child(program.blockParams);
        }
        var startType = void 0,
            endType = void 0;
        if (this.programDepth === 0) {
            startType = 'startProgram';
            endType = 'endProgram';
        } else {
            startType = 'startBlock';
            endType = 'endBlock';
        }
        programFrame.parentNode = program;
        programFrame.children = program.body;
        programFrame.childCount = program.body.length;
        programFrame.blankChildTextNodes = [];
        programFrame.actions.push([endType, [program, this.programDepth]]);
        programFrame.symbols = program['symbols'];
        for (var i = program.body.length - 1; i >= 0; i--) {
            programFrame.childIndex = i;
            this.visit(program.body[i]);
        }
        programFrame.actions.push([startType, [program, programFrame.childTemplateCount, programFrame.blankChildTextNodes.reverse()]]);
        this.popFrame();
        this.programDepth--;
        // Push the completed template into the global actions list
        if (parentFrame) {
            parentFrame.childTemplateCount++;
        }
        (_actions = this.actions).push.apply(_actions, programFrame.actions.reverse());
    };

    TemplateVisitor.prototype.ElementNode = function ElementNode(element) {
        var _parentFrame$actions;

        var parentFrame = this.currentFrame;
        var elementFrame = this.pushFrame();
        elementFrame.parentNode = element;
        elementFrame.children = element.children;
        elementFrame.childCount = element.children.length;
        elementFrame.mustacheCount += element.modifiers.length;
        elementFrame.blankChildTextNodes = [];
        elementFrame.symbols = element['symbols'] = parentFrame.symbols.child(element.blockParams);
        var actionArgs = [element, parentFrame.childIndex, parentFrame.childCount];
        elementFrame.actions.push(['closeElement', actionArgs]);
        for (var i = element.attributes.length - 1; i >= 0; i--) {
            this.visit(element.attributes[i]);
        }
        for (var _i = element.children.length - 1; _i >= 0; _i--) {
            elementFrame.childIndex = _i;
            this.visit(element.children[_i]);
        }
        var open = ['openElement', [].concat(actionArgs, [elementFrame.mustacheCount, elementFrame.blankChildTextNodes.reverse()])];
        elementFrame.actions.push(open);
        this.popFrame();
        // Propagate the element's frame state to the parent frame
        if (elementFrame.mustacheCount > 0) {
            parentFrame.mustacheCount++;
        }
        parentFrame.childTemplateCount += elementFrame.childTemplateCount;
        (_parentFrame$actions = parentFrame.actions).push.apply(_parentFrame$actions, elementFrame.actions);
    };

    TemplateVisitor.prototype.AttrNode = function AttrNode(attr) {
        if (attr.value.type !== 'TextNode') {
            this.currentFrame.mustacheCount++;
        }
    };

    TemplateVisitor.prototype.TextNode = function TextNode(text) {
        var frame = this.currentFrame;
        if (text.chars === '') {
            frame.blankChildTextNodes.push(domIndexOf(frame.children, text));
        }
        frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.BlockStatement = function BlockStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['block', [node, frame.childIndex, frame.childCount]]);
        if (node.inverse) {
            this.visit(node.inverse);
        }
        if (node.program) {
            this.visit(node.program);
        }
    };

    TemplateVisitor.prototype.PartialStatement = function PartialStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [node, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.CommentStatement = function CommentStatement(text) {
        var frame = this.currentFrame;
        frame.actions.push(['comment', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.MustacheCommentStatement = function MustacheCommentStatement() {
        // Intentional empty: Handlebars comments should not affect output.
    };

    TemplateVisitor.prototype.MustacheStatement = function MustacheStatement(mustache) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
    };
    // Frame helpers


    TemplateVisitor.prototype.getCurrentFrame = function getCurrentFrame() {
        return this.frameStack[this.frameStack.length - 1];
    };

    TemplateVisitor.prototype.pushFrame = function pushFrame() {
        var frame = new Frame();
        this.frameStack.push(frame);
        return frame;
    };

    TemplateVisitor.prototype.popFrame = function popFrame() {
        return this.frameStack.pop();
    };

    _createClass(TemplateVisitor, [{
        key: 'currentFrame',
        get: function get() {
            return this.getCurrentFrame();
        }
    }]);

    return TemplateVisitor;
}();
function domIndexOf(nodes, domNode) {
    var index = -1;
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.type !== 'TextNode' && node.type !== 'ElementNode') {
            continue;
        } else {
            index++;
        }
        if (node === domNode) {
            return index;
        }
    }
    return -1;
}

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Block = function () {
    function Block() {
        _classCallCheck$2(this, Block);

        this.statements = [];
    }

    Block.prototype.push = function push(statement) {
        this.statements.push(statement);
    };

    return Block;
}();
var InlineBlock = function (_Block) {
    _inherits$1(InlineBlock, _Block);

    function InlineBlock(table) {
        _classCallCheck$2(this, InlineBlock);

        var _this = _possibleConstructorReturn$1(this, _Block.call(this));

        _this.table = table;
        return _this;
    }

    InlineBlock.prototype.toJSON = function toJSON() {
        return {
            statements: this.statements,
            parameters: this.table.slots
        };
    };

    return InlineBlock;
}(Block);
var TemplateBlock = function (_Block2) {
    _inherits$1(TemplateBlock, _Block2);

    function TemplateBlock(symbolTable) {
        _classCallCheck$2(this, TemplateBlock);

        var _this2 = _possibleConstructorReturn$1(this, _Block2.call(this));

        _this2.symbolTable = symbolTable;
        _this2.type = 'template';
        _this2.yields = new util.DictSet();
        _this2.named = new util.DictSet();
        _this2.blocks = [];
        _this2.hasEval = false;
        return _this2;
    }

    TemplateBlock.prototype.push = function push(statement) {
        this.statements.push(statement);
    };

    TemplateBlock.prototype.toJSON = function toJSON() {
        return {
            symbols: this.symbolTable.symbols,
            statements: this.statements,
            hasEval: this.hasEval
        };
    };

    return TemplateBlock;
}(Block);
var ComponentBlock = function (_Block3) {
    _inherits$1(ComponentBlock, _Block3);

    function ComponentBlock(tag, table, selfClosing) {
        _classCallCheck$2(this, ComponentBlock);

        var _this3 = _possibleConstructorReturn$1(this, _Block3.call(this));

        _this3.tag = tag;
        _this3.table = table;
        _this3.selfClosing = selfClosing;
        _this3.attributes = [];
        _this3.arguments = [];
        _this3.inParams = true;
        _this3.positionals = [];
        return _this3;
    }

    ComponentBlock.prototype.push = function push(statement) {
        if (this.inParams) {
            if (wireFormat.isFlushElement(statement)) {
                this.inParams = false;
            } else if (wireFormat.isArgument(statement)) {
                this.arguments.push(statement);
            } else if (wireFormat.isAttribute(statement)) {
                this.attributes.push(statement);
            } else {
                throw new Error('Compile Error: only parameters allowed before flush-element');
            }
        } else {
            this.statements.push(statement);
        }
    };

    ComponentBlock.prototype.toJSON = function toJSON() {
        var args = this.arguments;
        var keys = args.map(function (arg) {
            return arg[1];
        });
        var values = args.map(function (arg) {
            return arg[2];
        });
        var block = this.selfClosing ? null : {
            statements: this.statements,
            parameters: this.table.slots
        };
        return [this.tag, this.attributes, [keys, values], block];
    };

    return ComponentBlock;
}(Block);
var Template = function () {
    function Template(symbols) {
        _classCallCheck$2(this, Template);

        this.block = new TemplateBlock(symbols);
    }

    Template.prototype.toJSON = function toJSON() {
        return this.block.toJSON();
    };

    return Template;
}();

var JavaScriptCompiler = function () {
    function JavaScriptCompiler(opcodes, symbols, options) {
        _classCallCheck$2(this, JavaScriptCompiler);

        this.blocks = new util.Stack();
        this.values = [];
        this.opcodes = opcodes;
        this.template = new Template(symbols);
        this.options = options;
    }

    JavaScriptCompiler.process = function process(opcodes, symbols, options) {
        var compiler = new JavaScriptCompiler(opcodes, symbols, options);
        return compiler.process();
    };

    JavaScriptCompiler.prototype.process = function process() {
        var _this4 = this;

        this.opcodes.forEach(function (op) {
            var opcode = op[0];
            var arg = op[1];
            if (!_this4[opcode]) {
                throw new Error('unimplemented ' + opcode + ' on JavaScriptCompiler');
            }
            _this4[opcode](arg);
        });
        return this.template;
    };
    /// Nesting


    JavaScriptCompiler.prototype.startBlock = function startBlock(program) {
        var block = new InlineBlock(program['symbols']);
        this.blocks.push(block);
    };

    JavaScriptCompiler.prototype.endBlock = function endBlock() {
        var template = this.template,
            blocks = this.blocks;

        var block = blocks.pop();
        template.block.blocks.push(block.toJSON());
    };

    JavaScriptCompiler.prototype.startProgram = function startProgram() {
        this.blocks.push(this.template.block);
    };

    JavaScriptCompiler.prototype.endProgram = function endProgram() {};
    /// Statements


    JavaScriptCompiler.prototype.text = function text(content) {
        this.push([wireFormat.Ops.Text, content]);
    };

    JavaScriptCompiler.prototype.append = function append(trusted) {
        this.push([wireFormat.Ops.Append, this.popValue(), trusted]);
    };

    JavaScriptCompiler.prototype.comment = function comment(value) {
        this.push([wireFormat.Ops.Comment, value]);
    };

    JavaScriptCompiler.prototype.modifier = function modifier(name) {
        var params = this.popValue();
        var hash = this.popValue();
        this.push([wireFormat.Ops.Modifier, name, params, hash]);
    };

    JavaScriptCompiler.prototype.block = function block(_ref) {
        var name = _ref[0],
            template = _ref[1],
            inverse = _ref[2];

        var params = this.popValue();
        var hash = this.popValue();
        var blocks = this.template.block.blocks;
        this.push([wireFormat.Ops.Block, name, params, hash, blocks[template], blocks[inverse]]);
    };

    JavaScriptCompiler.prototype.openComponent = function openComponent(element) {
        var tag = this.options && this.options.customizeComponentName ? this.options.customizeComponentName(element.tag) : element.tag;
        var component = new ComponentBlock(tag, element['symbols'], element.selfClosing);
        this.blocks.push(component);
    };

    JavaScriptCompiler.prototype.openSplattedElement = function openSplattedElement(element) {
        var tag = element.tag;
        if (element.blockParams.length > 0) {
            throw new Error('Compile Error: <' + element.tag + '> is not a component and doesn\'t support block parameters');
        } else {
            this.push([wireFormat.Ops.OpenSplattedElement, tag]);
        }
    };

    JavaScriptCompiler.prototype.openElement = function openElement(element) {
        var tag = element.tag;
        if (element.blockParams.length > 0) {
            throw new Error('Compile Error: <' + element.tag + '> is not a component and doesn\'t support block parameters');
        } else {
            this.push([wireFormat.Ops.OpenElement, tag]);
        }
    };

    JavaScriptCompiler.prototype.flushElement = function flushElement() {
        this.push([wireFormat.Ops.FlushElement]);
    };

    JavaScriptCompiler.prototype.closeComponent = function closeComponent(_element) {
        if (_element.modifiers.length > 0) {
            throw new Error('Compile Error: Element modifiers are not allowed in components');
        }

        var _endComponent = this.endComponent(),
            tag = _endComponent[0],
            attrs = _endComponent[1],
            args = _endComponent[2],
            block = _endComponent[3];

        this.push([wireFormat.Ops.Component, tag, attrs, args, block]);
    };

    JavaScriptCompiler.prototype.closeDynamicComponent = function closeDynamicComponent(_element) {
        var _endComponent2 = this.endComponent(),
            attrs = _endComponent2[1],
            args = _endComponent2[2],
            block = _endComponent2[3];

        this.push([wireFormat.Ops.DynamicComponent, this.popValue(), attrs, args, block]);
    };

    JavaScriptCompiler.prototype.closeElement = function closeElement(_element) {
        this.push([wireFormat.Ops.CloseElement]);
    };

    JavaScriptCompiler.prototype.staticAttr = function staticAttr(_ref2) {
        var name = _ref2[0],
            namespace = _ref2[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.StaticAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.dynamicAttr = function dynamicAttr(_ref3) {
        var name = _ref3[0],
            namespace = _ref3[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.DynamicAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.componentAttr = function componentAttr(_ref4) {
        var name = _ref4[0],
            namespace = _ref4[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.ComponentAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.trustingAttr = function trustingAttr(_ref5) {
        var name = _ref5[0],
            namespace = _ref5[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.TrustingAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.trustingComponentAttr = function trustingComponentAttr(_ref6) {
        var name = _ref6[0],
            namespace = _ref6[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.TrustingComponentAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.staticArg = function staticArg(name) {
        var value = this.popValue();
        this.push([wireFormat.Ops.StaticArg, name, value]);
    };

    JavaScriptCompiler.prototype.dynamicArg = function dynamicArg(name) {
        var value = this.popValue();
        this.push([wireFormat.Ops.DynamicArg, name, value]);
    };

    JavaScriptCompiler.prototype.yield = function _yield(to) {
        var params = this.popValue();
        this.push([wireFormat.Ops.Yield, to, params]);
    };

    JavaScriptCompiler.prototype.attrSplat = function attrSplat(to) {
        // consume (and disregard) the value pushed for the
        // ...attributes attribute
        this.popValue();
        this.push([wireFormat.Ops.AttrSplat, to]);
    };

    JavaScriptCompiler.prototype.debugger = function _debugger(evalInfo) {
        this.push([wireFormat.Ops.Debugger, evalInfo]);
        this.template.block.hasEval = true;
    };

    JavaScriptCompiler.prototype.hasBlock = function hasBlock(name) {
        this.pushValue([wireFormat.Ops.HasBlock, name]);
    };

    JavaScriptCompiler.prototype.hasBlockParams = function hasBlockParams(name) {
        this.pushValue([wireFormat.Ops.HasBlockParams, name]);
    };

    JavaScriptCompiler.prototype.partial = function partial(evalInfo) {
        var params = this.popValue();
        this.push([wireFormat.Ops.Partial, params[0], evalInfo]);
        this.template.block.hasEval = true;
    };
    /// Expressions


    JavaScriptCompiler.prototype.literal = function literal(value) {
        if (value === undefined) {
            this.pushValue([wireFormat.Ops.Undefined]);
        } else {
            this.pushValue(value);
        }
    };

    JavaScriptCompiler.prototype.unknown = function unknown(name) {
        this.pushValue([wireFormat.Ops.Unknown, name]);
    };

    JavaScriptCompiler.prototype.get = function get(_ref7) {
        var head = _ref7[0],
            path = _ref7[1];

        this.pushValue([wireFormat.Ops.Get, head, path]);
    };

    JavaScriptCompiler.prototype.maybeLocal = function maybeLocal(path) {
        this.pushValue([wireFormat.Ops.MaybeLocal, path]);
    };

    JavaScriptCompiler.prototype.concat = function concat() {
        this.pushValue([wireFormat.Ops.Concat, this.popValue()]);
    };

    JavaScriptCompiler.prototype.helper = function helper(name) {
        var params = this.popValue();
        var hash = this.popValue();
        this.pushValue([wireFormat.Ops.Helper, name, params, hash]);
    };
    /// Stack Management Opcodes


    JavaScriptCompiler.prototype.prepareArray = function prepareArray(size) {
        var values = [];
        for (var i = 0; i < size; i++) {
            values.push(this.popValue());
        }
        this.pushValue(values);
    };

    JavaScriptCompiler.prototype.prepareObject = function prepareObject(size) {
        var keys = new Array(size);
        var values = new Array(size);
        for (var i = 0; i < size; i++) {
            keys[i] = this.popValue();
            values[i] = this.popValue();
        }
        this.pushValue([keys, values]);
    };
    /// Utilities


    JavaScriptCompiler.prototype.endComponent = function endComponent() {
        var component = this.blocks.pop();
        return component.toJSON();
    };

    JavaScriptCompiler.prototype.push = function push(args) {
        while (args[args.length - 1] === null) {
            args.pop();
        }
        this.currentBlock.push(args);
    };

    JavaScriptCompiler.prototype.pushValue = function pushValue(val) {
        this.values.push(val);
    };

    JavaScriptCompiler.prototype.popValue = function popValue() {
        return this.values.pop();
    };

    _createClass$1(JavaScriptCompiler, [{
        key: 'currentBlock',
        get: function get() {
            return this.blocks.current;
        }
    }]);

    return JavaScriptCompiler;
}();

// There is a small whitelist of namespaced attributes specially
// enumerated in
// https://www.w3.org/TR/html/syntax.html#attributes-0
//
// > When a foreign element has one of the namespaced attributes given by
// > the local name and namespace of the first and second cells of a row
// > from the following table, it must be written using the name given by
// > the third cell from the same row.
//
// In all other cases, colons are interpreted as a regular character
// with no special meaning:
//
// > No other namespaced attribute can be expressed in the HTML syntax.
var XLINK = 'http://www.w3.org/1999/xlink';
var XML = 'http://www.w3.org/XML/1998/namespace';
var XMLNS = 'http://www.w3.org/2000/xmlns/';
var WHITELIST = {
    'xlink:actuate': XLINK,
    'xlink:arcrole': XLINK,
    'xlink:href': XLINK,
    'xlink:role': XLINK,
    'xlink:show': XLINK,
    'xlink:title': XLINK,
    'xlink:type': XLINK,
    'xml:base': XML,
    'xml:lang': XML,
    'xml:space': XML,
    xmlns: XMLNS,
    'xmlns:xlink': XMLNS
};
function getAttrNamespace(attrName) {
    return WHITELIST[attrName] || null;
}

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolAllocator = function () {
    function SymbolAllocator(ops) {
        _classCallCheck$3(this, SymbolAllocator);

        this.ops = ops;
        this.symbolStack = new util.Stack();
    }

    SymbolAllocator.prototype.process = function process() {
        var out = [];
        var ops = this.ops;

        for (var i = 0; i < ops.length; i++) {
            var op = ops[i];
            var result = this.dispatch(op);
            if (result === undefined) {
                out.push(op);
            } else {
                out.push(result);
            }
        }
        return out;
    };

    SymbolAllocator.prototype.dispatch = function dispatch(op) {
        var name = op[0];
        var operand = op[1];
        return this[name](operand);
    };

    SymbolAllocator.prototype.startProgram = function startProgram(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.endProgram = function endProgram(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.startBlock = function startBlock(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.endBlock = function endBlock(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.flushElement = function flushElement(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.closeElement = function closeElement(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeComponent = function closeComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeDynamicComponent = function closeDynamicComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.attrSplat = function attrSplat(_op) {
        return ['attrSplat', this.symbols.allocateBlock('attrs')];
    };

    SymbolAllocator.prototype.get = function get(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head = this.symbols.allocateNamed(name);
            return ['get', [_head, rest]];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.maybeGet = function maybeGet(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head2 = this.symbols.allocateNamed(name);
            return ['get', [_head2, rest]];
        } else if (rest.length === 0) {
            return ['unknown', name];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.yield = function _yield(op) {
        if (op === 0) {
            throw new Error('Cannot yield to this');
        }
        return ['yield', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.debugger = function _debugger(_op) {
        return ['debugger', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.hasBlock = function hasBlock(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlock this');
        }
        return ['hasBlock', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.hasBlockParams = function hasBlockParams(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlockParams this');
        }
        return ['hasBlockParams', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.partial = function partial(_op) {
        return ['partial', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.text = function text(_op) {};

    SymbolAllocator.prototype.comment = function comment(_op) {};

    SymbolAllocator.prototype.openComponent = function openComponent(_op) {};

    SymbolAllocator.prototype.openElement = function openElement(_op) {};

    SymbolAllocator.prototype.openSplattedElement = function openSplattedElement(_op) {};

    SymbolAllocator.prototype.staticArg = function staticArg(_op) {};

    SymbolAllocator.prototype.dynamicArg = function dynamicArg(_op) {};

    SymbolAllocator.prototype.staticAttr = function staticAttr(_op) {};

    SymbolAllocator.prototype.trustingAttr = function trustingAttr(_op) {};

    SymbolAllocator.prototype.trustingComponentAttr = function trustingComponentAttr(_op) {};

    SymbolAllocator.prototype.dynamicAttr = function dynamicAttr(_op) {};

    SymbolAllocator.prototype.componentAttr = function componentAttr(_op) {};

    SymbolAllocator.prototype.modifier = function modifier(_op) {};

    SymbolAllocator.prototype.append = function append(_op) {};

    SymbolAllocator.prototype.block = function block(_op) {};

    SymbolAllocator.prototype.literal = function literal(_op) {};

    SymbolAllocator.prototype.helper = function helper(_op) {};

    SymbolAllocator.prototype.unknown = function unknown(_op) {};

    SymbolAllocator.prototype.maybeLocal = function maybeLocal(_op) {};

    SymbolAllocator.prototype.prepareArray = function prepareArray(_op) {};

    SymbolAllocator.prototype.prepareObject = function prepareObject(_op) {};

    SymbolAllocator.prototype.concat = function concat(_op) {};

    _createClass$2(SymbolAllocator, [{
        key: 'symbols',
        get: function get() {
            return this.symbolStack.current;
        }
    }]);

    return SymbolAllocator;
}();
function isLocal(name, symbols) {
    return symbols && symbols.has(name);
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isTrustedValue(value) {
    return value.escaped !== undefined && !value.escaped;
}


var TemplateCompiler = function () {
    function TemplateCompiler() {
        _classCallCheck(this, TemplateCompiler);

        this.templateId = 0;
        this.templateIds = [];
        this.opcodes = [];
        this.includeMeta = false;
    }

    TemplateCompiler.compile = function compile(ast, options) {
        var templateVisitor = new TemplateVisitor();
        templateVisitor.visit(ast);
        var compiler = new TemplateCompiler();
        var opcodes = compiler.process(templateVisitor.actions);
        var symbols = new SymbolAllocator(opcodes).process();
        return JavaScriptCompiler.process(symbols, ast['symbols'], options);
    };

    TemplateCompiler.prototype.process = function process(actions) {
        var _this = this;

        actions.forEach(function (_ref) {
            var name = _ref[0],
                args = _ref.slice(1);

            if (!_this[name]) {
                throw new Error('Unimplemented ' + name + ' on TemplateCompiler');
            }
            _this[name].apply(_this, args);
        });
        return this.opcodes;
    };

    TemplateCompiler.prototype.startProgram = function startProgram(_ref2) {
        var program = _ref2[0];

        this.opcode(['startProgram', program], program);
    };

    TemplateCompiler.prototype.endProgram = function endProgram() {
        this.opcode(['endProgram', null], null);
    };

    TemplateCompiler.prototype.startBlock = function startBlock(_ref3) {
        var program = _ref3[0];

        this.templateId++;
        this.opcode(['startBlock', program], program);
    };

    TemplateCompiler.prototype.endBlock = function endBlock() {
        this.templateIds.push(this.templateId - 1);
        this.opcode(['endBlock', null], null);
    };

    TemplateCompiler.prototype.text = function text(_ref4) {
        var action = _ref4[0];

        this.opcode(['text', action.chars], action);
    };

    TemplateCompiler.prototype.comment = function comment(_ref5) {
        var action = _ref5[0];

        this.opcode(['comment', action.value], action);
    };

    TemplateCompiler.prototype.openElement = function openElement(_ref6) {
        var action = _ref6[0];

        var attributes = action.attributes;
        var hasSplat = false;
        for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            if (attr.name === '...attributes') {
                hasSplat = true;
                break;
            }
        }
        var actionIsComponent = false;
        if (isDynamicComponent(action)) {
            var head = void 0,
                rest = void 0;

            var _action$tag$split = action.tag.split('.');

            head = _action$tag$split[0];
            rest = _action$tag$split.slice(1);

            if (head === 'this') {
                head = 0;
            }
            this.opcode(['get', [head, rest]]);
            this.opcode(['openComponent', action], action);
            actionIsComponent = true;
        } else if (isComponent(action)) {
            this.opcode(['openComponent', action], action);
            actionIsComponent = true;
        } else if (hasSplat) {
            this.opcode(['openSplattedElement', action], action);
        } else {
            this.opcode(['openElement', action], action);
        }
        var typeAttr = null;
        var attrs = action.attributes;
        for (var _i = 0; _i < attrs.length; _i++) {
            if (attrs[_i].name === 'type') {
                typeAttr = attrs[_i];
                continue;
            }
            this.attribute([attrs[_i]], hasSplat || actionIsComponent);
        }
        if (typeAttr) {
            this.attribute([typeAttr], hasSplat || actionIsComponent);
        }
        this.opcode(['flushElement', action], null);
    };

    TemplateCompiler.prototype.closeElement = function closeElement(_ref7) {
        var action = _ref7[0];

        if (isDynamicComponent(action)) {
            this.opcode(['closeDynamicComponent', action], action);
        } else if (isComponent(action)) {
            this.opcode(['closeComponent', action], action);
        } else if (action.modifiers.length > 0) {
            for (var i = 0; i < action.modifiers.length; i++) {
                this.modifier([action.modifiers[i]]);
            }
            this.opcode(['closeElement', action], action);
        } else {
            this.opcode(['closeElement', action], action);
        }
    };

    TemplateCompiler.prototype.attribute = function attribute(_ref8, isComponent) {
        var action = _ref8[0];
        var name = action.name,
            value = action.value;

        var namespace = getAttrNamespace(name);
        var isStatic = this.prepareAttributeValue(value);
        if (name.charAt(0) === '@') {
            // Arguments
            if (isStatic) {
                this.opcode(['staticArg', name], action);
            } else if (action.value.type === 'MustacheStatement') {
                this.opcode(['dynamicArg', name], action);
            } else {
                this.opcode(['dynamicArg', name], action);
            }
        } else {
            var isTrusting = isTrustedValue(value);
            if (isStatic && name === '...attributes') {
                this.opcode(['attrSplat', null], action);
            } else if (isStatic && !isComponent) {
                this.opcode(['staticAttr', [name, namespace]], action);
            } else if (isTrusting) {
                this.opcode([isComponent ? 'trustingComponentAttr' : 'trustingAttr', [name, namespace]], action);
            } else if (action.value.type === 'MustacheStatement') {
                this.opcode([isComponent ? 'componentAttr' : 'dynamicAttr', [name, null]], action);
            } else {
                this.opcode([isComponent ? 'componentAttr' : 'dynamicAttr', [name, namespace]], action);
            }
        }
    };

    TemplateCompiler.prototype.modifier = function modifier(_ref9) {
        var action = _ref9[0];

        assertIsSimplePath(action.path, action.loc, 'modifier');
        var parts = action.path.parts;

        this.prepareHelper(action);
        this.opcode(['modifier', parts[0]], action);
    };

    TemplateCompiler.prototype.mustache = function mustache(_ref10) {
        var action = _ref10[0];
        var path = action.path;

        if (syntax.isLiteral(path)) {
            this.mustacheExpression(action);
            this.opcode(['append', !action.escaped], action);
        } else if (isYield(path)) {
            var to = assertValidYield(action);
            this.yield(to, action);
        } else if (isPartial(path)) {
            var params = assertValidPartial(action);
            this.partial(params, action);
        } else if (isDebugger(path)) {
            assertValidDebuggerUsage(action);
            this.debugger('debugger', action);
        } else {
            this.mustacheExpression(action);
            this.opcode(['append', !action.escaped], action);
        }
    };

    TemplateCompiler.prototype.block = function block(_ref11) {
        var action /*, index, count*/ = _ref11[0];

        this.prepareHelper(action);
        var templateId = this.templateIds.pop();
        var inverseId = action.inverse === null ? null : this.templateIds.pop();
        this.opcode(['block', [action.path.parts[0], templateId, inverseId]], action);
    };
    /// Internal actions, not found in the original processed actions


    TemplateCompiler.prototype.arg = function arg(_ref12) {
        var path = _ref12[0];

        var _path$parts = path.parts,
            head = _path$parts[0],
            rest = _path$parts.slice(1);

        this.opcode(['get', ['@' + head, rest]], path);
    };

    TemplateCompiler.prototype.mustacheExpression = function mustacheExpression(expr) {
        var path = expr.path;

        if (syntax.isLiteral(path)) {
            this.opcode(['literal', path.value], expr);
        } else if (isBuiltInHelper(path)) {
            this.builtInHelper(expr);
        } else if (isArg(path)) {
            this.arg([path]);
        } else if (isHelperInvocation(expr)) {
            this.prepareHelper(expr);
            this.opcode(['helper', path.parts[0]], expr);
        } else if (path.this) {
            this.opcode(['get', [0, path.parts]], expr);
        } else {
            var _path$parts2 = path.parts,
                head = _path$parts2[0],
                parts = _path$parts2.slice(1);

            this.opcode(['maybeGet', [head, parts]], expr);
        }
        // } else if (isLocal(path, this.symbols)) {
        //   let [head, ...parts] = path.parts;
        //   this.opcode(['get', [head, parts]], expr);
        // } else if (isSimplePath(path)) {
        //   this.opcode(['unknown', path.parts[0]], expr);
        // } else {
        //   this.opcode(['maybeLocal', path.parts], expr);
        // }
    };
    /// Internal Syntax


    TemplateCompiler.prototype.yield = function _yield(to, action) {
        this.prepareParams(action.params);
        this.opcode(['yield', to], action);
    };

    TemplateCompiler.prototype.debugger = function _debugger(_name, action) {
        this.opcode(['debugger', null], action);
    };

    TemplateCompiler.prototype.hasBlock = function hasBlock(name, action) {
        this.opcode(['hasBlock', name], action);
    };

    TemplateCompiler.prototype.hasBlockParams = function hasBlockParams(name, action) {
        this.opcode(['hasBlockParams', name], action);
    };

    TemplateCompiler.prototype.partial = function partial(_params, action) {
        this.prepareParams(action.params);
        this.opcode(['partial', null], action);
    };

    TemplateCompiler.prototype.builtInHelper = function builtInHelper(expr) {
        var path = expr.path;

        if (isHasBlock(path)) {
            var name = assertValidHasBlockUsage(expr.path.original, expr);
            this.hasBlock(name, expr);
        } else if (isHasBlockParams(path)) {
            var _name2 = assertValidHasBlockUsage(expr.path.original, expr);
            this.hasBlockParams(_name2, expr);
        }
    };
    /// Expressions, invoked recursively from prepareParams and prepareHash


    TemplateCompiler.prototype.SubExpression = function SubExpression(expr) {
        if (isBuiltInHelper(expr.path)) {
            this.builtInHelper(expr);
        } else {
            this.prepareHelper(expr);
            this.opcode(['helper', expr.path.parts[0]], expr);
        }
    };

    TemplateCompiler.prototype.PathExpression = function PathExpression(expr) {
        if (expr.data) {
            this.arg([expr]);
        } else {
            var _expr$parts = expr.parts,
                head = _expr$parts[0],
                rest = _expr$parts.slice(1);

            if (expr.this) {
                this.opcode(['get', [0, expr.parts]], expr);
            } else {
                this.opcode(['get', [head, rest]], expr);
            }
        }
    };

    TemplateCompiler.prototype.StringLiteral = function StringLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.BooleanLiteral = function BooleanLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.NumberLiteral = function NumberLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.NullLiteral = function NullLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.UndefinedLiteral = function UndefinedLiteral(action) {
        this.opcode(['literal', action.value], action);
    };
    /// Utilities


    TemplateCompiler.prototype.opcode = function opcode(_opcode) {
        var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // TODO: This doesn't really work
        if (this.includeMeta && action) {
            _opcode.push(this.meta(action));
        }
        this.opcodes.push(_opcode);
    };

    TemplateCompiler.prototype.prepareHelper = function prepareHelper(expr) {
        assertIsSimplePath(expr.path, expr.loc, 'helper');
        var params = expr.params,
            hash = expr.hash;

        this.prepareHash(hash);
        this.prepareParams(params);
    };

    TemplateCompiler.prototype.prepareParams = function prepareParams(params) {
        if (!params.length) {
            this.opcode(['literal', null], null);
            return;
        }
        for (var i = params.length - 1; i >= 0; i--) {
            var param = params[i];
            this[param.type](param);
        }
        this.opcode(['prepareArray', params.length], null);
    };

    TemplateCompiler.prototype.prepareHash = function prepareHash(hash) {
        var pairs = hash.pairs;
        if (!pairs.length) {
            this.opcode(['literal', null], null);
            return;
        }
        for (var i = pairs.length - 1; i >= 0; i--) {
            var _pairs$i = pairs[i],
                key = _pairs$i.key,
                value = _pairs$i.value;

            this[value.type](value);
            this.opcode(['literal', key], null);
        }
        this.opcode(['prepareObject', pairs.length], null);
    };

    TemplateCompiler.prototype.prepareAttributeValue = function prepareAttributeValue(value) {
        // returns the static value if the value is static
        switch (value.type) {
            case 'TextNode':
                this.opcode(['literal', value.chars], value);
                return true;
            case 'MustacheStatement':
                this.attributeMustache([value]);
                return false;
            case 'ConcatStatement':
                this.prepareConcatParts(value.parts);
                this.opcode(['concat', null], value);
                return false;
        }
    };

    TemplateCompiler.prototype.prepareConcatParts = function prepareConcatParts(parts) {
        for (var i = parts.length - 1; i >= 0; i--) {
            var part = parts[i];
            if (part.type === 'MustacheStatement') {
                this.attributeMustache([part]);
            } else if (part.type === 'TextNode') {
                this.opcode(['literal', part.chars], null);
            }
        }
        this.opcode(['prepareArray', parts.length], null);
    };

    TemplateCompiler.prototype.attributeMustache = function attributeMustache(_ref13) {
        var action = _ref13[0];

        this.mustacheExpression(action);
    };

    TemplateCompiler.prototype.meta = function meta(node) {
        var loc = node.loc;
        if (!loc) {
            return [];
        }
        var source = loc.source,
            start = loc.start,
            end = loc.end;

        return ['loc', [source || null, [start.line, start.column], [end.line, end.column]]];
    };

    return TemplateCompiler;
}();

function isHelperInvocation(mustache) {
    return mustache.params && mustache.params.length > 0 || mustache.hash && mustache.hash.pairs.length > 0;
}
function isSimplePath(_ref14) {
    var parts = _ref14.parts;

    return parts.length === 1;
}
function isYield(path) {
    return path.original === 'yield';
}
function isPartial(path) {
    return path.original === 'partial';
}
function isDebugger(path) {
    return path.original === 'debugger';
}
function isHasBlock(path) {
    return path.original === 'has-block';
}
function isHasBlockParams(path) {
    return path.original === 'has-block-params';
}
function isBuiltInHelper(path) {
    return isHasBlock(path) || isHasBlockParams(path);
}
function isArg(path) {
    return !!path['data'];
}
function isDynamicComponent(element) {
    var open = element.tag.charAt(0);

    var _element$tag$split = element.tag.split('.'),
        maybeLocal = _element$tag$split[0];

    var isNamedArgument = open === '@';
    var isLocal = element['symbols'].has(maybeLocal);
    var isThisPath = element.tag.indexOf('this.') === 0;
    return isLocal || isNamedArgument || isThisPath;
}
function isComponent(element) {
    var open = element.tag.charAt(0);
    var isPath = element.tag.indexOf('.') > -1;
    var isUpperCase = open === open.toUpperCase() && open !== open.toLowerCase();
    return isUpperCase && !isPath || isDynamicComponent(element);
}
function assertIsSimplePath(path, loc, context) {
    if (!isSimplePath(path)) {
        throw new syntax.SyntaxError('`' + path.original + '` is not a valid name for a ' + context + ' on line ' + loc.start.line + '.', path.loc);
    }
}
function assertValidYield(statement) {
    var pairs = statement.hash.pairs;

    if (pairs.length === 1 && pairs[0].key !== 'to' || pairs.length > 1) {
        throw new syntax.SyntaxError('yield only takes a single named argument: \'to\'', statement.loc);
    } else if (pairs.length === 1 && pairs[0].value.type !== 'StringLiteral') {
        throw new syntax.SyntaxError('you can only yield to a literal value', statement.loc);
    } else if (pairs.length === 0) {
        return 'default';
    } else {
        return pairs[0].value.value;
    }
}
function assertValidPartial(statement) {
    var params = statement.params,
        hash = statement.hash,
        escaped = statement.escaped,
        loc = statement.loc;

    if (params && params.length !== 1) {
        throw new syntax.SyntaxError('Partial found with no arguments. You must specify a template name. (on line ' + loc.start.line + ')', statement.loc);
    } else if (hash && hash.pairs.length > 0) {
        throw new syntax.SyntaxError('partial does not take any named arguments (on line ' + loc.start.line + ')', statement.loc);
    } else if (!escaped) {
        throw new syntax.SyntaxError('{{{partial ...}}} is not supported, please use {{partial ...}} instead (on line ' + loc.start.line + ')', statement.loc);
    }
    return params;
}
function assertValidHasBlockUsage(type, call) {
    var params = call.params,
        hash = call.hash,
        loc = call.loc;

    if (hash && hash.pairs.length > 0) {
        throw new syntax.SyntaxError(type + ' does not take any named arguments', call.loc);
    }
    if (params.length === 0) {
        return 'default';
    } else if (params.length === 1) {
        var param = params[0];
        if (param.type === 'StringLiteral') {
            return param.value;
        } else {
            throw new syntax.SyntaxError('you can only yield to a literal value (on line ' + loc.start.line + ')', call.loc);
        }
    } else {
        throw new syntax.SyntaxError(type + ' only takes a single positional argument (on line ' + loc.start.line + ')', call.loc);
    }
}
function assertValidDebuggerUsage(statement) {
    var params = statement.params,
        hash = statement.hash;

    if (hash && hash.pairs.length > 0) {
        throw new syntax.SyntaxError('debugger does not take any named arguments', statement.loc);
    }
    if (params.length === 0) {
        return 'default';
    } else {
        throw new syntax.SyntaxError('debugger does not take any positional arguments', statement.loc);
    }
}

var defaultId = function () {
    if (typeof require === 'function') {
        try {
            /* tslint:disable:no-require-imports */
            var crypto = require('crypto');
            /* tslint:enable:no-require-imports */
            var idFn = function idFn(src) {
                var hash = crypto.createHash('sha1');
                hash.update(src, 'utf8');
                // trim to 6 bytes of data (2^48 - 1)
                return hash.digest('base64').substring(0, 8);
            };
            idFn('test');
            return idFn;
        } catch (e) {}
    }
    return function idFn() {
        return null;
    };
}();
var defaultOptions = {
    id: defaultId,
    meta: {}
};
function precompile(string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

    var ast = syntax.preprocess(string, options);
    var meta = options.meta;

    var _TemplateCompiler$com = TemplateCompiler.compile(ast, options),
        block = _TemplateCompiler$com.block;

    var idFn = options.id || defaultId;
    var blockJSON = JSON.stringify(block.toJSON());
    var templateJSONObject = {
        id: idFn(JSON.stringify(meta) + blockJSON),
        block: blockJSON,
        meta: meta
    };
    // JSON is javascript
    return JSON.stringify(templateJSONObject);
}

exports.defaultId = defaultId;
exports.precompile = precompile;
exports.TemplateCompiler = TemplateCompiler;
exports.TemplateVisitor = TemplateVisitor;

Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1jb21waWxlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL3RlbXBsYXRlLXZpc2l0b3IudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9jb21waWxlci9saWIvamF2YXNjcmlwdC1jb21waWxlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi91dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9hbGxvY2F0ZS1zeW1ib2xzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL2NvbXBpbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTVCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBDb3JlIH0gZnJvbSAnQGdsaW1tZXIvd2lyZS1mb3JtYXQnO1xuaW1wb3J0IHsgRGljdCwgT3B0aW9uLCBkaWN0LCB1bnJlYWNoYWJsZSwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTeW1ib2xUYWJsZSB7XG4gIHN0YXRpYyB0b3AoKTogUHJvZ3JhbVN5bWJvbFRhYmxlIHtcbiAgICByZXR1cm4gbmV3IFByb2dyYW1TeW1ib2xUYWJsZSgpO1xuICB9XG5cbiAgYWJzdHJhY3QgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW47XG4gIGFic3RyYWN0IGdldChuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG5cbiAgYWJzdHJhY3QgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPjtcbiAgYWJzdHJhY3QgZ2V0RXZhbEluZm8oKTogQ29yZS5FdmFsSW5mbztcblxuICBhYnN0cmFjdCBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlcjtcbiAgYWJzdHJhY3QgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gIGFic3RyYWN0IGFsbG9jYXRlKGlkZW50aWZpZXI6IHN0cmluZyk6IG51bWJlcjtcblxuICBjaGlsZChsb2NhbHM6IHN0cmluZ1tdKTogQmxvY2tTeW1ib2xUYWJsZSB7XG4gICAgbGV0IHN5bWJvbHMgPSBsb2NhbHMubWFwKG5hbWUgPT4gdGhpcy5hbGxvY2F0ZShuYW1lKSk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja1N5bWJvbFRhYmxlKHRoaXMsIGxvY2Fscywgc3ltYm9scyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByb2dyYW1TeW1ib2xUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlIHtcbiAgcHVibGljIHN5bWJvbHM6IHN0cmluZ1tdID0gW107XG5cbiAgcHJpdmF0ZSBzaXplID0gMTtcbiAgcHJpdmF0ZSBuYW1lZCA9IGRpY3Q8bnVtYmVyPigpO1xuICBwcml2YXRlIGJsb2NrcyA9IGRpY3Q8bnVtYmVyPigpO1xuXG4gIGhhcyhfbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0KF9uYW1lOiBzdHJpbmcpOiBuZXZlciB7XG4gICAgdGhyb3cgdW5yZWFjaGFibGUoKTtcbiAgfVxuXG4gIGdldExvY2Fsc01hcCgpOiBEaWN0PG51bWJlcj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm8ge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGFsbG9jYXRlTmFtZWQobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBsZXQgbmFtZWQgPSB0aGlzLm5hbWVkW25hbWVdO1xuXG4gICAgaWYgKCFuYW1lZCkge1xuICAgICAgbmFtZWQgPSB0aGlzLm5hbWVkW25hbWVdID0gdGhpcy5hbGxvY2F0ZShuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZWQ7XG4gIH1cblxuICBhbGxvY2F0ZUJsb2NrKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IGJsb2NrID0gdGhpcy5ibG9ja3NbbmFtZV07XG5cbiAgICBpZiAoIWJsb2NrKSB7XG4gICAgICBibG9jayA9IHRoaXMuYmxvY2tzW25hbWVdID0gdGhpcy5hbGxvY2F0ZShgJiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHRoaXMuc3ltYm9scy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIHJldHVybiB0aGlzLnNpemUrKztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tTeW1ib2xUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnQ6IFN5bWJvbFRhYmxlLCBwdWJsaWMgc3ltYm9sczogc3RyaW5nW10sIHB1YmxpYyBzbG90czogbnVtYmVyW10pIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKSAhPT0gLTEgfHwgdGhpcy5wYXJlbnQuaGFzKG5hbWUpO1xuICB9XG5cbiAgZ2V0KG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IHNsb3QgPSB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2xvdCA9PT0gLTEgPyB0aGlzLnBhcmVudC5nZXQobmFtZSkgOiB0aGlzLnNsb3RzW3Nsb3RdO1xuICB9XG5cbiAgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPiB7XG4gICAgbGV0IGRpY3QgPSB0aGlzLnBhcmVudC5nZXRMb2NhbHNNYXAoKTtcbiAgICB0aGlzLnN5bWJvbHMuZm9yRWFjaChzeW1ib2wgPT4gKGRpY3Rbc3ltYm9sXSA9IHRoaXMuZ2V0KHN5bWJvbCkpKTtcbiAgICByZXR1cm4gZGljdDtcbiAgfVxuXG4gIGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm8ge1xuICAgIGxldCBsb2NhbHMgPSB0aGlzLmdldExvY2Fsc01hcCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsb2NhbHMpLm1hcChzeW1ib2wgPT4gbG9jYWxzW3N5bWJvbF0pO1xuICB9XG5cbiAgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZU5hbWVkKG5hbWUpO1xuICB9XG5cbiAgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZUJsb2NrKG5hbWUpO1xuICB9XG5cbiAgYWxsb2NhdGUoaWRlbnRpZmllcjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYWxsb2NhdGUoaWRlbnRpZmllcik7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBpbiBhbiBBU1QgYW5kIG91dHB1dHMgYSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgY29uc3VtZWRcbiAqIGJ5IGEgY29tcGlsZXIuIEZvciBleGFtcGxlLCB0aGUgdGVtcGxhdGVcbiAqXG4gKiAgICAgZm9ve3tiYXJ9fTxkaXY+YmF6PC9kaXY+XG4gKlxuICogcHJvZHVjZXMgdGhlIGFjdGlvbnNcbiAqXG4gKiAgICAgW1snc3RhcnRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgM11dLFxuICogICAgICBbJ211c3RhY2hlJywgW211c3RhY2hlTm9kZSwgMSwgM11dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAyLCAzLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgMV1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMiwgM10sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dXVxuICpcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyB0aGUgQVNUIGRlcHRoIGZpcnN0IGFuZCBiYWNrd2FyZHMuIEFzXG4gKiBhIHJlc3VsdCB0aGUgYm90dG9tLW1vc3QgY2hpbGQgdGVtcGxhdGUgd2lsbCBhcHBlYXIgYXQgdGhlXG4gKiB0b3Agb2YgdGhlIGFjdGlvbnMgbGlzdCB3aGVyZWFzIHRoZSByb290IHRlbXBsYXRlIHdpbGwgYXBwZWFyXG4gKiBhdCB0aGUgYm90dG9tIG9mIHRoZSBsaXN0LiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgPGRpdj57eyNpZn19Zm9ve3tlbHNlfX1iYXI8Yj48L2I+e3svaWZ9fTwvZGl2PlxuICpcbiAqIHByb2R1Y2VzIHRoZSBhY3Rpb25zXG4gKlxuICogICAgIFtbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMF1dLFxuICogICAgICBbJ3RleHQnLCBbdGV4dE5vZGUsIDAsIDIsIDBdXSxcbiAqICAgICAgWydvcGVuRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMSwgMiwgMF1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMSwgMl1dLFxuICogICAgICBbJ2VuZFByb2dyYW0nLCBbcHJvZ3JhbU5vZGVdXSxcbiAqICAgICAgWydzdGFydFByb2dyYW0nLCBbcHJvZ3JhbU5vZGUsIDBdXSxcbiAqICAgICAgWyd0ZXh0JywgW3RleHROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dLFxuICogICAgICBbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMl1dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAwLCAxLCAxXV0sXG4gKiAgICAgIFsnYmxvY2snLCBbYmxvY2tOb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnY2xvc2VFbGVtZW50JywgW2VsZW1lbnROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dXVxuICpcbiAqIFRoZSBzdGF0ZSBvZiB0aGUgdHJhdmVyc2FsIGlzIG1haW50YWluZWQgYnkgYSBzdGFjayBvZiBmcmFtZXMuXG4gKiBXaGVuZXZlciBhIG5vZGUgd2l0aCBjaGlsZHJlbiBpcyBlbnRlcmVkIChlaXRoZXIgYSBQcm9ncmFtTm9kZVxuICogb3IgYW4gRWxlbWVudE5vZGUpIGEgZnJhbWUgaXMgcHVzaGVkIG9udG8gdGhlIHN0YWNrLiBUaGUgZnJhbWVcbiAqIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGF0ZSBvZiB0aGUgdHJhdmVyc2FsIG9mIHRoYXRcbiAqIG5vZGUuIEZvciBleGFtcGxlLFxuICpcbiAqICAgLSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGlsZCBub2RlIGJlaW5nIHZpc2l0ZWRcbiAqICAgLSB0aGUgbnVtYmVyIG9mIG11c3RhY2hlcyBjb250YWluZWQgd2l0aGluIGl0cyBjaGlsZCBub2Rlc1xuICogICAtIHRoZSBsaXN0IG9mIGFjdGlvbnMgZ2VuZXJhdGVkIGJ5IGl0cyBjaGlsZCBub2Rlc1xuICovXG5cbmNsYXNzIEZyYW1lIHtcbiAgcHVibGljIHBhcmVudE5vZGU6IE9wdGlvbjxPYmplY3Q+ID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBPcHRpb248QVNULk5vZGVbXT4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRJbmRleDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRDb3VudDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRUZW1wbGF0ZUNvdW50ID0gMDtcbiAgcHVibGljIG11c3RhY2hlQ291bnQgPSAwO1xuICBwdWJsaWMgYWN0aW9uczogQWN0aW9uW10gPSBbXTtcbiAgcHVibGljIGJsYW5rQ2hpbGRUZXh0Tm9kZXM6IE9wdGlvbjxudW1iZXJbXT4gPSBudWxsO1xuICBwdWJsaWMgc3ltYm9sczogT3B0aW9uPFN5bWJvbFRhYmxlPiA9IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQWN0aW9uIHtcbiAgZXhwb3J0IHR5cGUgU3RhcnRQcm9ncmFtID0gWydzdGFydFByb2dyYW0nLCBbQVNULlByb2dyYW0sIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgRW5kUHJvZ3JhbSA9IFsnZW5kUHJvZ3JhbScsIFtBU1QuUHJvZ3JhbSwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIFN0YXJ0QmxvY2sgPSBbJ3N0YXJ0QmxvY2snLCBbQVNULlByb2dyYW0sIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgRW5kQmxvY2sgPSBbJ2VuZEJsb2NrJywgW0FTVC5Qcm9ncmFtLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgQmxvY2sgPSBbJ2Jsb2NrJywgW0FTVC5CbG9ja1N0YXRlbWVudCwgbnVtYmVyLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgTXVzdGFjaGUgPSBbXG4gICAgJ211c3RhY2hlJyxcbiAgICBbQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlBhcnRpYWxTdGF0ZW1lbnQsIG51bWJlciwgbnVtYmVyXVxuICBdO1xuICBleHBvcnQgdHlwZSBPcGVuRWxlbWVudCA9IFsnb3BlbkVsZW1lbnQnLCBbQVNULkVsZW1lbnROb2RlLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJbXV1dO1xuICBleHBvcnQgdHlwZSBDbG9zZUVsZW1lbnQgPSBbJ2Nsb3NlRWxlbWVudCcsIFtBU1QuRWxlbWVudE5vZGUsIG51bWJlciwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIFRleHQgPSBbJ3RleHQnLCBbQVNULlRleHROb2RlLCBudW1iZXIsIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBDb21tZW50ID0gWydjb21tZW50JywgW0FTVC5Db21tZW50U3RhdGVtZW50LCBudW1iZXIsIG51bWJlcl1dO1xuXG4gIGV4cG9ydCB0eXBlIEFjdGlvbiA9XG4gICAgfCBTdGFydFByb2dyYW1cbiAgICB8IEVuZFByb2dyYW1cbiAgICB8IFN0YXJ0QmxvY2tcbiAgICB8IEVuZEJsb2NrXG4gICAgfCBCbG9ja1xuICAgIHwgTXVzdGFjaGVcbiAgICB8IE9wZW5FbGVtZW50XG4gICAgfCBDbG9zZUVsZW1lbnRcbiAgICB8IFRleHRcbiAgICB8IENvbW1lbnQ7XG59XG5cbmV4cG9ydCB0eXBlIEFjdGlvbiA9IEFjdGlvbi5BY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlVmlzaXRvciB7XG4gIHByaXZhdGUgZnJhbWVTdGFjazogRnJhbWVbXSA9IFtdO1xuICBwdWJsaWMgYWN0aW9uczogQWN0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBwcm9ncmFtRGVwdGggPSAtMTtcblxuICB2aXNpdChub2RlOiBBU1QuQmFzZU5vZGUpIHtcbiAgICB0aGlzW25vZGUudHlwZV0obm9kZSk7XG4gIH1cblxuICAvLyBUcmF2ZXJzYWwgbWV0aG9kc1xuXG4gIFByb2dyYW0ocHJvZ3JhbTogQVNULlByb2dyYW0pIHtcbiAgICB0aGlzLnByb2dyYW1EZXB0aCsrO1xuXG4gICAgbGV0IHBhcmVudEZyYW1lID0gdGhpcy5nZXRDdXJyZW50RnJhbWUoKTtcbiAgICBsZXQgcHJvZ3JhbUZyYW1lID0gdGhpcy5wdXNoRnJhbWUoKTtcblxuICAgIGlmICghcGFyZW50RnJhbWUpIHtcbiAgICAgIHByb2dyYW1bJ3N5bWJvbHMnXSA9IFN5bWJvbFRhYmxlLnRvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmFtWydzeW1ib2xzJ10gPSBwYXJlbnRGcmFtZS5zeW1ib2xzIS5jaGlsZChwcm9ncmFtLmJsb2NrUGFyYW1zKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnRUeXBlOiBzdHJpbmcsIGVuZFR5cGU6IHN0cmluZztcblxuICAgIGlmICh0aGlzLnByb2dyYW1EZXB0aCA9PT0gMCkge1xuICAgICAgc3RhcnRUeXBlID0gJ3N0YXJ0UHJvZ3JhbSc7XG4gICAgICBlbmRUeXBlID0gJ2VuZFByb2dyYW0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFR5cGUgPSAnc3RhcnRCbG9jayc7XG4gICAgICBlbmRUeXBlID0gJ2VuZEJsb2NrJztcbiAgICB9XG5cbiAgICBwcm9ncmFtRnJhbWUucGFyZW50Tm9kZSA9IHByb2dyYW07XG4gICAgcHJvZ3JhbUZyYW1lLmNoaWxkcmVuID0gcHJvZ3JhbS5ib2R5O1xuICAgIHByb2dyYW1GcmFtZS5jaGlsZENvdW50ID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aDtcbiAgICBwcm9ncmFtRnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyA9IFtdO1xuICAgIHByb2dyYW1GcmFtZS5hY3Rpb25zLnB1c2goW2VuZFR5cGUsIFtwcm9ncmFtLCB0aGlzLnByb2dyYW1EZXB0aF1dIGFzIEFjdGlvbik7XG4gICAgcHJvZ3JhbUZyYW1lLnN5bWJvbHMgPSBwcm9ncmFtWydzeW1ib2xzJ107XG5cbiAgICBmb3IgKGxldCBpID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwcm9ncmFtRnJhbWUuY2hpbGRJbmRleCA9IGk7XG4gICAgICB0aGlzLnZpc2l0KHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgcHJvZ3JhbUZyYW1lLmFjdGlvbnMucHVzaChbXG4gICAgICBzdGFydFR5cGUsXG4gICAgICBbcHJvZ3JhbSwgcHJvZ3JhbUZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCwgcHJvZ3JhbUZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMucmV2ZXJzZSgpXSxcbiAgICBdIGFzIEFjdGlvbik7XG4gICAgdGhpcy5wb3BGcmFtZSgpO1xuXG4gICAgdGhpcy5wcm9ncmFtRGVwdGgtLTtcblxuICAgIC8vIFB1c2ggdGhlIGNvbXBsZXRlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBnbG9iYWwgYWN0aW9ucyBsaXN0XG4gICAgaWYgKHBhcmVudEZyYW1lKSB7XG4gICAgICBwYXJlbnRGcmFtZS5jaGlsZFRlbXBsYXRlQ291bnQrKztcbiAgICB9XG4gICAgdGhpcy5hY3Rpb25zLnB1c2goLi4ucHJvZ3JhbUZyYW1lLmFjdGlvbnMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIEVsZW1lbnROb2RlKGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCBwYXJlbnRGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGxldCBlbGVtZW50RnJhbWUgPSB0aGlzLnB1c2hGcmFtZSgpO1xuXG4gICAgZWxlbWVudEZyYW1lLnBhcmVudE5vZGUgPSBlbGVtZW50O1xuICAgIGVsZW1lbnRGcmFtZS5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgZWxlbWVudEZyYW1lLmNoaWxkQ291bnQgPSBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICBlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCArPSBlbGVtZW50Lm1vZGlmaWVycy5sZW5ndGg7XG4gICAgZWxlbWVudEZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMgPSBbXTtcbiAgICBlbGVtZW50RnJhbWUuc3ltYm9scyA9IGVsZW1lbnRbJ3N5bWJvbHMnXSA9IHBhcmVudEZyYW1lLnN5bWJvbHMhLmNoaWxkKGVsZW1lbnQuYmxvY2tQYXJhbXMpO1xuXG4gICAgbGV0IGFjdGlvbkFyZ3M6IFtBU1QuRWxlbWVudE5vZGUsIG51bWJlciwgbnVtYmVyXSA9IFtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYXJlbnRGcmFtZS5jaGlsZEluZGV4ISxcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkQ291bnQhLFxuICAgIF07XG5cbiAgICBlbGVtZW50RnJhbWUuYWN0aW9ucy5wdXNoKFsnY2xvc2VFbGVtZW50JywgYWN0aW9uQXJnc10pO1xuXG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy52aXNpdChlbGVtZW50LmF0dHJpYnV0ZXNbaV0pO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlbGVtZW50RnJhbWUuY2hpbGRJbmRleCA9IGk7XG4gICAgICB0aGlzLnZpc2l0KGVsZW1lbnQuY2hpbGRyZW5baV0pO1xuICAgIH1cblxuICAgIGxldCBvcGVuID0gW1xuICAgICAgJ29wZW5FbGVtZW50JyxcbiAgICAgIFsuLi5hY3Rpb25BcmdzLCBlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCwgZWxlbWVudEZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMucmV2ZXJzZSgpXSxcbiAgICBdIGFzIEFjdGlvbi5PcGVuRWxlbWVudDtcbiAgICBlbGVtZW50RnJhbWUuYWN0aW9ucy5wdXNoKG9wZW4pO1xuXG4gICAgdGhpcy5wb3BGcmFtZSgpO1xuXG4gICAgLy8gUHJvcGFnYXRlIHRoZSBlbGVtZW50J3MgZnJhbWUgc3RhdGUgdG8gdGhlIHBhcmVudCBmcmFtZVxuICAgIGlmIChlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCA+IDApIHtcbiAgICAgIHBhcmVudEZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICB9XG4gICAgcGFyZW50RnJhbWUuY2hpbGRUZW1wbGF0ZUNvdW50ICs9IGVsZW1lbnRGcmFtZS5jaGlsZFRlbXBsYXRlQ291bnQ7XG4gICAgcGFyZW50RnJhbWUuYWN0aW9ucy5wdXNoKC4uLmVsZW1lbnRGcmFtZS5hY3Rpb25zKTtcbiAgfVxuXG4gIEF0dHJOb2RlKGF0dHI6IEFTVC5BdHRyTm9kZSkge1xuICAgIGlmIChhdHRyLnZhbHVlLnR5cGUgIT09ICdUZXh0Tm9kZScpIHtcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICB9XG4gIH1cblxuICBUZXh0Tm9kZSh0ZXh0OiBBU1QuVGV4dE5vZGUpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBpZiAodGV4dC5jaGFycyA9PT0gJycpIHtcbiAgICAgIGZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMhLnB1c2goZG9tSW5kZXhPZihmcmFtZS5jaGlsZHJlbiEsIHRleHQpKTtcbiAgICB9XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsndGV4dCcsIFt0ZXh0LCBmcmFtZS5jaGlsZEluZGV4LCBmcmFtZS5jaGlsZENvdW50XV0gYXMgQWN0aW9uKTtcbiAgfVxuXG4gIEJsb2NrU3RhdGVtZW50KG5vZGU6IEFTVC5CbG9ja1N0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXG4gICAgZnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ2Jsb2NrJywgW25vZGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuXG4gICAgaWYgKG5vZGUuaW52ZXJzZSkge1xuICAgICAgdGhpcy52aXNpdChub2RlLmludmVyc2UpO1xuICAgIH1cbiAgICBpZiAobm9kZS5wcm9ncmFtKSB7XG4gICAgICB0aGlzLnZpc2l0KG5vZGUucHJvZ3JhbSk7XG4gICAgfVxuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChub2RlOiBBU1QuUGFydGlhbFN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWydtdXN0YWNoZScsIFtub2RlLCBmcmFtZS5jaGlsZEluZGV4LCBmcmFtZS5jaGlsZENvdW50XV0gYXMgQWN0aW9uKTtcbiAgfVxuXG4gIENvbW1lbnRTdGF0ZW1lbnQodGV4dDogQVNULkNvbW1lbnRTdGF0ZW1lbnQpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWydjb21tZW50JywgW3RleHQsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KCkge1xuICAgIC8vIEludGVudGlvbmFsIGVtcHR5OiBIYW5kbGViYXJzIGNvbW1lbnRzIHNob3VsZCBub3QgYWZmZWN0IG91dHB1dC5cbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBmcmFtZS5tdXN0YWNoZUNvdW50Kys7XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsnbXVzdGFjaGUnLCBbbXVzdGFjaGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgLy8gRnJhbWUgaGVscGVyc1xuXG4gIHByaXZhdGUgZ2V0IGN1cnJlbnRGcmFtZSgpOiBGcmFtZSB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmdldEN1cnJlbnRGcmFtZSgpLCAnRXhwZWN0ZWQgYSBjdXJyZW50IGZyYW1lJyk7XG4gIH1cblxuICBwcml2YXRlIGdldEN1cnJlbnRGcmFtZSgpOiBPcHRpb248RnJhbWU+IHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZVN0YWNrW3RoaXMuZnJhbWVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHByaXZhdGUgcHVzaEZyYW1lKCkge1xuICAgIGxldCBmcmFtZSA9IG5ldyBGcmFtZSgpO1xuICAgIHRoaXMuZnJhbWVTdGFjay5wdXNoKGZyYW1lKTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICBwcml2YXRlIHBvcEZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lU3RhY2sucG9wKCk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgYGRvbU5vZGVgIGluIHRoZSBgbm9kZXNgIGFycmF5LCBza2lwcGluZ1xuLy8gb3ZlciBhbnkgbm9kZXMgd2hpY2ggZG8gbm90IHJlcHJlc2VudCBET00gbm9kZXMuXG5mdW5jdGlvbiBkb21JbmRleE9mKG5vZGVzOiBBU1QuTm9kZVtdLCBkb21Ob2RlOiBBU1QuVGV4dE5vZGUgfCBBU1QuRWxlbWVudE5vZGUpIHtcbiAgbGV0IGluZGV4ID0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSAnVGV4dE5vZGUnICYmIG5vZGUudHlwZSAhPT0gJ0VsZW1lbnROb2RlJykge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4iLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFN0YWNrLCBEaWN0U2V0LCBPcHRpb24sIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVNUIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IEJsb2NrU3ltYm9sVGFibGUsIFByb2dyYW1TeW1ib2xUYWJsZSB9IGZyb20gJy4vdGVtcGxhdGUtdmlzaXRvcic7XG5pbXBvcnQgeyBDb21waWxlT3B0aW9ucyB9IGZyb20gJy4vdGVtcGxhdGUtY29tcGlsZXInO1xuaW1wb3J0IHtcbiAgU2VyaWFsaXplZElubGluZUJsb2NrLFxuICBTZXJpYWxpemVkVGVtcGxhdGVCbG9jayxcbiAgQ29yZSxcbiAgU3RhdGVtZW50LFxuICBTdGF0ZW1lbnRzLFxuICBFeHByZXNzaW9uLFxuICBFeHByZXNzaW9ucyxcbiAgT3BzLFxuICBpc0ZsdXNoRWxlbWVudCxcbiAgaXNBcmd1bWVudCxcbiAgaXNBdHRyaWJ1dGUsXG59IGZyb20gJ0BnbGltbWVyL3dpcmUtZm9ybWF0JztcbmltcG9ydCB7IFByb2Nlc3NvciwgQ29tcGlsZXJPcHMsIE9wTmFtZSwgT3AgfSBmcm9tICcuL2NvbXBpbGVyLW9wcyc7XG5cbmV4cG9ydCB0eXBlIHN0ciA9IHN0cmluZztcbmV4cG9ydCB0eXBlIFBhcmFtcyA9IENvcmUuUGFyYW1zO1xuZXhwb3J0IHR5cGUgSGFzaCA9IENvcmUuSGFzaDtcbmV4cG9ydCB0eXBlIFBhdGggPSBDb3JlLlBhdGg7XG5leHBvcnQgdHlwZSBTdGFja1ZhbHVlID0gRXhwcmVzc2lvbiB8IFBhcmFtcyB8IEhhc2ggfCBzdHI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCbG9jayB7XG4gIHB1YmxpYyBzdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXG4gIGFic3RyYWN0IHRvSlNPTigpOiBPYmplY3Q7XG5cbiAgcHVzaChzdGF0ZW1lbnQ6IFN0YXRlbWVudCkge1xuICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIElubGluZUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFibGU6IEJsb2NrU3ltYm9sVGFibGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgdG9KU09OKCk6IFNlcmlhbGl6ZWRJbmxpbmVCbG9jayB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlbWVudHM6IHRoaXMuc3RhdGVtZW50cyxcbiAgICAgIHBhcmFtZXRlcnM6IHRoaXMudGFibGUuc2xvdHMsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgcHVibGljIHR5cGUgPSAndGVtcGxhdGUnO1xuICBwdWJsaWMgeWllbGRzID0gbmV3IERpY3RTZXQ8c3RyaW5nPigpO1xuICBwdWJsaWMgbmFtZWQgPSBuZXcgRGljdFNldDxzdHJpbmc+KCk7XG4gIHB1YmxpYyBibG9ja3M6IFNlcmlhbGl6ZWRJbmxpbmVCbG9ja1tdID0gW107XG4gIHB1YmxpYyBoYXNFdmFsID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzeW1ib2xUYWJsZTogUHJvZ3JhbVN5bWJvbFRhYmxlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1c2goc3RhdGVtZW50OiBTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpO1xuICB9XG5cbiAgdG9KU09OKCk6IFNlcmlhbGl6ZWRUZW1wbGF0ZUJsb2NrIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3ltYm9sczogdGhpcy5zeW1ib2xUYWJsZS5zeW1ib2xzLFxuICAgICAgc3RhdGVtZW50czogdGhpcy5zdGF0ZW1lbnRzLFxuICAgICAgaGFzRXZhbDogdGhpcy5oYXNFdmFsLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbXBvbmVudEJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICBwdWJsaWMgYXR0cmlidXRlczogU3RhdGVtZW50cy5BdHRyaWJ1dGVbXSA9IFtdO1xuICBwdWJsaWMgYXJndW1lbnRzOiBTdGF0ZW1lbnRzLkFyZ3VtZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBpblBhcmFtcyA9IHRydWU7XG4gIHB1YmxpYyBwb3NpdGlvbmFsczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhZzogc3RyaW5nLCBwcml2YXRlIHRhYmxlOiBCbG9ja1N5bWJvbFRhYmxlLCBwcml2YXRlIHNlbGZDbG9zaW5nOiBib29sZWFuKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1c2goc3RhdGVtZW50OiBTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy5pblBhcmFtcykge1xuICAgICAgaWYgKGlzRmx1c2hFbGVtZW50KHN0YXRlbWVudCkpIHtcbiAgICAgICAgdGhpcy5pblBhcmFtcyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0FyZ3VtZW50KHN0YXRlbWVudCkpIHtcbiAgICAgICAgdGhpcy5hcmd1bWVudHMucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0F0dHJpYnV0ZShzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBpbGUgRXJyb3I6IG9ubHkgcGFyYW1ldGVycyBhbGxvd2VkIGJlZm9yZSBmbHVzaC1lbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCk6IFtzdHJpbmcsIFN0YXRlbWVudHMuQXR0cmlidXRlW10sIENvcmUuSGFzaCwgT3B0aW9uPFNlcmlhbGl6ZWRJbmxpbmVCbG9jaz5dIHtcbiAgICBsZXQgYXJncyA9IHRoaXMuYXJndW1lbnRzO1xuICAgIGxldCBrZXlzID0gYXJncy5tYXAoYXJnID0+IGFyZ1sxXSk7XG4gICAgbGV0IHZhbHVlcyA9IGFyZ3MubWFwKGFyZyA9PiBhcmdbMl0pO1xuICAgIGxldCBibG9jayA9IHRoaXMuc2VsZkNsb3NpbmdcbiAgICAgID8gbnVsbFxuICAgICAgOiB7XG4gICAgICAgICAgc3RhdGVtZW50czogdGhpcy5zdGF0ZW1lbnRzLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRoaXMudGFibGUuc2xvdHMsXG4gICAgICAgIH07XG5cbiAgICByZXR1cm4gW3RoaXMudGFnLCB0aGlzLmF0dHJpYnV0ZXMsIFtrZXlzLCB2YWx1ZXNdLCBibG9ja107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlIHtcbiAgcHVibGljIGJsb2NrOiBUZW1wbGF0ZUJsb2NrO1xuXG4gIGNvbnN0cnVjdG9yKHN5bWJvbHM6IFByb2dyYW1TeW1ib2xUYWJsZSkge1xuICAgIHRoaXMuYmxvY2sgPSBuZXcgVGVtcGxhdGVCbG9jayhzeW1ib2xzKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBTZXJpYWxpemVkVGVtcGxhdGVCbG9jayB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2sudG9KU09OKCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgSW5WYXJpYWJsZSA9IG51bWJlcjtcbmV4cG9ydCB0eXBlIEluT3A8SyBleHRlbmRzIGtleW9mIENvbXBpbGVyT3BzPEluVmFyaWFibGU+ID0gT3BOYW1lPiA9IE9wPFxuICBJblZhcmlhYmxlLFxuICBDb21waWxlck9wczxJblZhcmlhYmxlPixcbiAgS1xuPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSmF2YVNjcmlwdENvbXBpbGVyXG4gIGltcGxlbWVudHMgUHJvY2Vzc29yPENvbXBpbGVyT3BzPG51bWJlcj4sIHZvaWQsIENvbXBpbGVyT3BzPHZvaWQ+PiB7XG4gIHN0YXRpYyBwcm9jZXNzKG9wY29kZXM6IEluT3BbXSwgc3ltYm9sczogUHJvZ3JhbVN5bWJvbFRhYmxlLCBvcHRpb25zPzogQ29tcGlsZU9wdGlvbnMpOiBUZW1wbGF0ZSB7XG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IEphdmFTY3JpcHRDb21waWxlcihvcGNvZGVzLCBzeW1ib2xzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tcGlsZXIucHJvY2VzcygpO1xuICB9XG5cbiAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGU7XG4gIHByaXZhdGUgYmxvY2tzID0gbmV3IFN0YWNrPEJsb2NrPigpO1xuICBwcml2YXRlIG9wY29kZXM6IEluT3BbXTtcbiAgcHJpdmF0ZSB2YWx1ZXM6IFN0YWNrVmFsdWVbXSA9IFtdO1xuICBwcml2YXRlIG9wdGlvbnM6IENvbXBpbGVPcHRpb25zIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKG9wY29kZXM6IEluT3BbXSwgc3ltYm9sczogUHJvZ3JhbVN5bWJvbFRhYmxlLCBvcHRpb25zPzogQ29tcGlsZU9wdGlvbnMpIHtcbiAgICB0aGlzLm9wY29kZXMgPSBvcGNvZGVzO1xuICAgIHRoaXMudGVtcGxhdGUgPSBuZXcgVGVtcGxhdGUoc3ltYm9scyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBjdXJyZW50QmxvY2soKTogQmxvY2sge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5ibG9ja3MuY3VycmVudCwgJ0V4cGVjdGVkIGEgYmxvY2sgb24gdGhlIHN0YWNrJyk7XG4gIH1cblxuICBwcm9jZXNzKCk6IFRlbXBsYXRlIHtcbiAgICB0aGlzLm9wY29kZXMuZm9yRWFjaChvcCA9PiB7XG4gICAgICBsZXQgb3Bjb2RlID0gb3BbMF07XG4gICAgICBsZXQgYXJnID0gb3BbMV07XG5cbiAgICAgIGlmICghdGhpc1tvcGNvZGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5pbXBsZW1lbnRlZCAke29wY29kZX0gb24gSmF2YVNjcmlwdENvbXBpbGVyYCk7XG4gICAgICB9XG4gICAgICAodGhpc1tvcGNvZGVdIGFzIGFueSkoYXJnKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlO1xuICB9XG5cbiAgLy8vIE5lc3RpbmdcblxuICBzdGFydEJsb2NrKHByb2dyYW06IEFTVC5Qcm9ncmFtKSB7XG4gICAgbGV0IGJsb2NrOiBCbG9jayA9IG5ldyBJbmxpbmVCbG9jayhwcm9ncmFtWydzeW1ib2xzJ10pO1xuICAgIHRoaXMuYmxvY2tzLnB1c2goYmxvY2spO1xuICB9XG5cbiAgZW5kQmxvY2soKSB7XG4gICAgbGV0IHsgdGVtcGxhdGUsIGJsb2NrcyB9ID0gdGhpcztcbiAgICBsZXQgYmxvY2sgPSBibG9ja3MucG9wKCkgYXMgSW5saW5lQmxvY2s7XG4gICAgdGVtcGxhdGUuYmxvY2suYmxvY2tzLnB1c2goYmxvY2sudG9KU09OKCkpO1xuICB9XG5cbiAgc3RhcnRQcm9ncmFtKCkge1xuICAgIHRoaXMuYmxvY2tzLnB1c2godGhpcy50ZW1wbGF0ZS5ibG9jayk7XG4gIH1cblxuICBlbmRQcm9ncmFtKCkge31cblxuICAvLy8gU3RhdGVtZW50c1xuXG4gIHRleHQoY29udGVudDogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuVGV4dCwgY29udGVudF0pO1xuICB9XG5cbiAgYXBwZW5kKHRydXN0ZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnB1c2goW09wcy5BcHBlbmQsIHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKSwgdHJ1c3RlZF0pO1xuICB9XG5cbiAgY29tbWVudCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuQ29tbWVudCwgdmFsdWVdKTtcbiAgfVxuXG4gIG1vZGlmaWVyKG5hbWU6IHN0cmluZykge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICBsZXQgaGFzaCA9IHRoaXMucG9wVmFsdWU8SGFzaD4oKTtcblxuICAgIHRoaXMucHVzaChbT3BzLk1vZGlmaWVyLCBuYW1lLCBwYXJhbXMsIGhhc2hdKTtcbiAgfVxuXG4gIGJsb2NrKFtuYW1lLCB0ZW1wbGF0ZSwgaW52ZXJzZV06IFtzdHJpbmcsIG51bWJlciwgT3B0aW9uPG51bWJlcj5dKSB7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMucG9wVmFsdWU8UGFyYW1zPigpO1xuICAgIGxldCBoYXNoID0gdGhpcy5wb3BWYWx1ZTxIYXNoPigpO1xuXG4gICAgbGV0IGJsb2NrcyA9IHRoaXMudGVtcGxhdGUuYmxvY2suYmxvY2tzO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ251bWJlcicgfHwgYmxvY2tzW3RlbXBsYXRlXSAhPT0gbnVsbCxcbiAgICAgICdtaXNzaW5nIGJsb2NrIGluIHRoZSBjb21waWxlcidcbiAgICApO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBpbnZlcnNlICE9PSAnbnVtYmVyJyB8fCBibG9ja3NbaW52ZXJzZV0gIT09IG51bGwsXG4gICAgICAnbWlzc2luZyBibG9jayBpbiB0aGUgY29tcGlsZXInXG4gICAgKTtcblxuICAgIHRoaXMucHVzaChbT3BzLkJsb2NrLCBuYW1lLCBwYXJhbXMsIGhhc2gsIGJsb2Nrc1t0ZW1wbGF0ZV0sIGJsb2Nrc1tpbnZlcnNlIV1dKTtcbiAgfVxuXG4gIG9wZW5Db21wb25lbnQoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IHRhZyA9XG4gICAgICB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWVcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZShlbGVtZW50LnRhZylcbiAgICAgICAgOiBlbGVtZW50LnRhZztcbiAgICBsZXQgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudEJsb2NrKHRhZywgZWxlbWVudFsnc3ltYm9scyddLCBlbGVtZW50LnNlbGZDbG9zaW5nKTtcbiAgICB0aGlzLmJsb2Nrcy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICBvcGVuU3BsYXR0ZWRFbGVtZW50KGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCB0YWcgPSBlbGVtZW50LnRhZztcblxuICAgIGlmIChlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBpbGUgRXJyb3I6IDwke2VsZW1lbnQudGFnfT4gaXMgbm90IGEgY29tcG9uZW50IGFuZCBkb2Vzbid0IHN1cHBvcnQgYmxvY2sgcGFyYW1ldGVyc2BcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChbT3BzLk9wZW5TcGxhdHRlZEVsZW1lbnQsIHRhZ10pO1xuICAgIH1cbiAgfVxuXG4gIG9wZW5FbGVtZW50KGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCB0YWcgPSBlbGVtZW50LnRhZztcblxuICAgIGlmIChlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBpbGUgRXJyb3I6IDwke2VsZW1lbnQudGFnfT4gaXMgbm90IGEgY29tcG9uZW50IGFuZCBkb2Vzbid0IHN1cHBvcnQgYmxvY2sgcGFyYW1ldGVyc2BcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChbT3BzLk9wZW5FbGVtZW50LCB0YWddKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaEVsZW1lbnQoKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuRmx1c2hFbGVtZW50XSk7XG4gIH1cblxuICBjbG9zZUNvbXBvbmVudChfZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgaWYgKF9lbGVtZW50Lm1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBpbGUgRXJyb3I6IEVsZW1lbnQgbW9kaWZpZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wb25lbnRzJyk7XG4gICAgfVxuICAgIGxldCBbdGFnLCBhdHRycywgYXJncywgYmxvY2tdID0gdGhpcy5lbmRDb21wb25lbnQoKTtcblxuICAgIHRoaXMucHVzaChbT3BzLkNvbXBvbmVudCwgdGFnLCBhdHRycywgYXJncywgYmxvY2tdKTtcbiAgfVxuXG4gIGNsb3NlRHluYW1pY0NvbXBvbmVudChfZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IFssIGF0dHJzLCBhcmdzLCBibG9ja10gPSB0aGlzLmVuZENvbXBvbmVudCgpO1xuXG4gICAgdGhpcy5wdXNoKFtPcHMuRHluYW1pY0NvbXBvbmVudCwgdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpLCBhdHRycywgYXJncywgYmxvY2tdKTtcbiAgfVxuXG4gIGNsb3NlRWxlbWVudChfZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuQ2xvc2VFbGVtZW50XSk7XG4gIH1cblxuICBzdGF0aWNBdHRyKFtuYW1lLCBuYW1lc3BhY2VdOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuU3RhdGljQXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV0pO1xuICB9XG5cbiAgZHluYW1pY0F0dHIoW25hbWUsIG5hbWVzcGFjZV06IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5EeW5hbWljQXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV0pO1xuICB9XG5cbiAgY29tcG9uZW50QXR0cihbbmFtZSwgbmFtZXNwYWNlXTogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpO1xuICAgIHRoaXMucHVzaChbT3BzLkNvbXBvbmVudEF0dHIsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKTtcbiAgfVxuXG4gIHRydXN0aW5nQXR0cihbbmFtZSwgbmFtZXNwYWNlXTogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpO1xuICAgIHRoaXMucHVzaChbT3BzLlRydXN0aW5nQXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSFdKTtcbiAgfVxuXG4gIHRydXN0aW5nQ29tcG9uZW50QXR0cihbbmFtZSwgbmFtZXNwYWNlXTogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpO1xuICAgIHRoaXMucHVzaChbT3BzLlRydXN0aW5nQ29tcG9uZW50QXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSFdKTtcbiAgfVxuXG4gIHN0YXRpY0FyZyhuYW1lOiBzdHIpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuU3RhdGljQXJnLCBuYW1lLCB2YWx1ZV0pO1xuICB9XG5cbiAgZHluYW1pY0FyZyhuYW1lOiBzdHIpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuRHluYW1pY0FyZywgbmFtZSwgdmFsdWVdKTtcbiAgfVxuXG4gIHlpZWxkKHRvOiBudW1iZXIpIHtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5wb3BWYWx1ZTxQYXJhbXM+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuWWllbGQsIHRvLCBwYXJhbXNdKTtcbiAgfVxuXG4gIGF0dHJTcGxhdCh0bzogT3B0aW9uPG51bWJlcj4pIHtcbiAgICAvLyBjb25zdW1lIChhbmQgZGlzcmVnYXJkKSB0aGUgdmFsdWUgcHVzaGVkIGZvciB0aGVcbiAgICAvLyAuLi5hdHRyaWJ1dGVzIGF0dHJpYnV0ZVxuICAgIHRoaXMucG9wVmFsdWUoKTtcbiAgICB0aGlzLnB1c2goW09wcy5BdHRyU3BsYXQsIHRvIV0pO1xuICB9XG5cbiAgZGVidWdnZXIoZXZhbEluZm86IE9wdGlvbjxDb3JlLkV2YWxJbmZvPikge1xuICAgIHRoaXMucHVzaChbT3BzLkRlYnVnZ2VyLCBldmFsSW5mbyFdKTtcbiAgICB0aGlzLnRlbXBsYXRlLmJsb2NrLmhhc0V2YWwgPSB0cnVlO1xuICB9XG5cbiAgaGFzQmxvY2sobmFtZTogbnVtYmVyKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuSGFzQmxvY2s+KFtPcHMuSGFzQmxvY2ssIG5hbWVdKTtcbiAgfVxuXG4gIGhhc0Jsb2NrUGFyYW1zKG5hbWU6IG51bWJlcikge1xuICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLkhhc0Jsb2NrUGFyYW1zPihbT3BzLkhhc0Jsb2NrUGFyYW1zLCBuYW1lXSk7XG4gIH1cblxuICBwYXJ0aWFsKGV2YWxJbmZvOiBPcHRpb248Q29yZS5FdmFsSW5mbz4pIHtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5wb3BWYWx1ZTxQYXJhbXM+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuUGFydGlhbCwgcGFyYW1zWzBdLCBldmFsSW5mbyFdKTtcbiAgICB0aGlzLnRlbXBsYXRlLmJsb2NrLmhhc0V2YWwgPSB0cnVlO1xuICB9XG5cbiAgLy8vIEV4cHJlc3Npb25zXG5cbiAgbGl0ZXJhbCh2YWx1ZTogRXhwcmVzc2lvbnMuVmFsdWUgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuVW5kZWZpbmVkPihbT3BzLlVuZGVmaW5lZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5WYWx1ZT4odmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHVua25vd24obmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuVW5rbm93bj4oW09wcy5Vbmtub3duLCBuYW1lXSk7XG4gIH1cblxuICBnZXQoW2hlYWQsIHBhdGhdOiBbbnVtYmVyLCBzdHJpbmdbXV0pIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5HZXQ+KFtPcHMuR2V0LCBoZWFkLCBwYXRoXSk7XG4gIH1cblxuICBtYXliZUxvY2FsKHBhdGg6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuTWF5YmVMb2NhbD4oW09wcy5NYXliZUxvY2FsLCBwYXRoXSk7XG4gIH1cblxuICBjb25jYXQoKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuQ29uY2F0PihbT3BzLkNvbmNhdCwgdGhpcy5wb3BWYWx1ZTxQYXJhbXM+KCldKTtcbiAgfVxuXG4gIGhlbHBlcihuYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5wb3BWYWx1ZTxQYXJhbXM+KCk7XG4gICAgbGV0IGhhc2ggPSB0aGlzLnBvcFZhbHVlPEhhc2g+KCk7XG5cbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5IZWxwZXI+KFtPcHMuSGVscGVyLCBuYW1lLCBwYXJhbXMsIGhhc2hdKTtcbiAgfVxuXG4gIC8vLyBTdGFjayBNYW5hZ2VtZW50IE9wY29kZXNcblxuICBwcmVwYXJlQXJyYXkoc2l6ZTogbnVtYmVyKSB7XG4gICAgbGV0IHZhbHVlczogRXhwcmVzc2lvbltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2godGhpcy5wb3BWYWx1ZSgpIGFzIEV4cHJlc3Npb24pO1xuICAgIH1cblxuICAgIHRoaXMucHVzaFZhbHVlPFBhcmFtcz4odmFsdWVzKTtcbiAgfVxuXG4gIHByZXBhcmVPYmplY3Qoc2l6ZTogbnVtYmVyKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdGhpcy52YWx1ZXMubGVuZ3RoID49IHNpemUsXG4gICAgICBgRXhwZWN0ZWQgJHtzaXplfSB2YWx1ZXMgb24gdGhlIHN0YWNrLCBmb3VuZCAke3RoaXMudmFsdWVzLmxlbmd0aH1gXG4gICAgKTtcblxuICAgIGxldCBrZXlzOiBzdHJpbmdbXSA9IG5ldyBBcnJheShzaXplKTtcbiAgICBsZXQgdmFsdWVzOiBFeHByZXNzaW9uW10gPSBuZXcgQXJyYXkoc2l6ZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAga2V5c1tpXSA9IHRoaXMucG9wVmFsdWU8c3RyPigpO1xuICAgICAgdmFsdWVzW2ldID0gdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaFZhbHVlPEhhc2g+KFtrZXlzLCB2YWx1ZXNdKTtcbiAgfVxuXG4gIC8vLyBVdGlsaXRpZXNcblxuICBlbmRDb21wb25lbnQoKTogW3N0cmluZywgU3RhdGVtZW50cy5BdHRyaWJ1dGVbXSwgQ29yZS5IYXNoLCBPcHRpb248U2VyaWFsaXplZElubGluZUJsb2NrPl0ge1xuICAgIGxldCBjb21wb25lbnQgPSB0aGlzLmJsb2Nrcy5wb3AoKTtcbiAgICBhc3NlcnQoXG4gICAgICBjb21wb25lbnQgaW5zdGFuY2VvZiBDb21wb25lbnRCbG9jayxcbiAgICAgICdDb21waWxlciBidWc6IGVuZENvbXBvbmVudCgpIHNob3VsZCBlbmQgYSBjb21wb25lbnQnXG4gICAgKTtcblxuICAgIHJldHVybiAoY29tcG9uZW50IGFzIENvbXBvbmVudEJsb2NrKS50b0pTT04oKTtcbiAgfVxuXG4gIHB1c2goYXJnczogU3RhdGVtZW50KSB7XG4gICAgd2hpbGUgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuICAgICAgYXJncy5wb3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRCbG9jay5wdXNoKGFyZ3MpO1xuICB9XG5cbiAgcHVzaFZhbHVlPFMgZXh0ZW5kcyBFeHByZXNzaW9uIHwgUGFyYW1zIHwgSGFzaD4odmFsOiBTKSB7XG4gICAgdGhpcy52YWx1ZXMucHVzaCh2YWwpO1xuICB9XG5cbiAgcG9wVmFsdWU8VCBleHRlbmRzIFN0YWNrVmFsdWU+KCk6IFQge1xuICAgIGFzc2VydCh0aGlzLnZhbHVlcy5sZW5ndGgsICdObyBleHByZXNzaW9uIGZvdW5kIG9uIHN0YWNrJyk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLnBvcCgpIGFzIFQ7XG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzT3Bjb2Rlcyhjb21waWxlcjogYW55LCBvcGNvZGVzOiBhbnkpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBvcGNvZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBtZXRob2QgPSBvcGNvZGVzW2ldWzBdO1xuICAgIGxldCBwYXJhbXMgPSBvcGNvZGVzW2ldWzFdO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGNvbXBpbGVyW21ldGhvZF0uYXBwbHkoY29tcGlsZXIsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBpbGVyW21ldGhvZF0uY2FsbChjb21waWxlcik7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZXJlIGlzIGEgc21hbGwgd2hpdGVsaXN0IG9mIG5hbWVzcGFjZWQgYXR0cmlidXRlcyBzcGVjaWFsbHlcbi8vIGVudW1lcmF0ZWQgaW5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMFxuLy9cbi8vID4gV2hlbiBhIGZvcmVpZ24gZWxlbWVudCBoYXMgb25lIG9mIHRoZSBuYW1lc3BhY2VkIGF0dHJpYnV0ZXMgZ2l2ZW4gYnlcbi8vID4gdGhlIGxvY2FsIG5hbWUgYW5kIG5hbWVzcGFjZSBvZiB0aGUgZmlyc3QgYW5kIHNlY29uZCBjZWxscyBvZiBhIHJvd1xuLy8gPiBmcm9tIHRoZSBmb2xsb3dpbmcgdGFibGUsIGl0IG11c3QgYmUgd3JpdHRlbiB1c2luZyB0aGUgbmFtZSBnaXZlbiBieVxuLy8gPiB0aGUgdGhpcmQgY2VsbCBmcm9tIHRoZSBzYW1lIHJvdy5cbi8vXG4vLyBJbiBhbGwgb3RoZXIgY2FzZXMsIGNvbG9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgYSByZWd1bGFyIGNoYXJhY3RlclxuLy8gd2l0aCBubyBzcGVjaWFsIG1lYW5pbmc6XG4vL1xuLy8gPiBObyBvdGhlciBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBIVE1MIHN5bnRheC5cblxuY29uc3QgWExJTksgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBYTUwgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbmNvbnN0IFhNTE5TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJztcblxuY29uc3QgV0hJVEVMSVNUID0ge1xuICAneGxpbms6YWN0dWF0ZSc6IFhMSU5LLFxuICAneGxpbms6YXJjcm9sZSc6IFhMSU5LLFxuICAneGxpbms6aHJlZic6IFhMSU5LLFxuICAneGxpbms6cm9sZSc6IFhMSU5LLFxuICAneGxpbms6c2hvdyc6IFhMSU5LLFxuICAneGxpbms6dGl0bGUnOiBYTElOSyxcbiAgJ3hsaW5rOnR5cGUnOiBYTElOSyxcbiAgJ3htbDpiYXNlJzogWE1MLFxuICAneG1sOmxhbmcnOiBYTUwsXG4gICd4bWw6c3BhY2UnOiBYTUwsXG4gIHhtbG5zOiBYTUxOUyxcbiAgJ3htbG5zOnhsaW5rJzogWE1MTlMsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0ck5hbWVzcGFjZShhdHRyTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBXSElURUxJU1RbYXR0ck5hbWVdIHx8IG51bGw7XG59XG4iLCJpbXBvcnQgeyBDb21waWxlck9wcywgUHJvY2Vzc29yLCBPcCwgT3BOYW1lLCBUZW1wbGF0ZUNvbXBpbGVyT3BzLCBQYXRoSGVhZCB9IGZyb20gJy4vY29tcGlsZXItb3BzJztcbmltcG9ydCB7IEFTVCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBPcHRpb24sIE9wYXF1ZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3RhY2ssIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgU3ltYm9sVGFibGUgfSBmcm9tICcuL3RlbXBsYXRlLXZpc2l0b3InO1xuXG5leHBvcnQgdHlwZSBJblZhcmlhYmxlID0gUGF0aEhlYWQ7XG5leHBvcnQgdHlwZSBPdXRWYXJpYWJsZSA9IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgT3V0T3A8SyBleHRlbmRzIGtleW9mIENvbXBpbGVyT3BzPE91dFZhcmlhYmxlPiA9IE9wTmFtZT4gPSBPcDxcbiAgT3V0VmFyaWFibGUsXG4gIENvbXBpbGVyT3BzPE91dFZhcmlhYmxlPixcbiAgS1xuPjtcbmV4cG9ydCB0eXBlIEluT3A8SyBleHRlbmRzIGtleW9mIFRlbXBsYXRlQ29tcGlsZXJPcHMgPSBrZXlvZiBUZW1wbGF0ZUNvbXBpbGVyT3BzPiA9IE9wPFxuICBQYXRoSGVhZCxcbiAgVGVtcGxhdGVDb21waWxlck9wcyxcbiAgS1xuPjtcblxuZXhwb3J0IGNsYXNzIFN5bWJvbEFsbG9jYXRvclxuICBpbXBsZW1lbnRzIFByb2Nlc3NvcjxDb21waWxlck9wczxJblZhcmlhYmxlPiwgT3V0VmFyaWFibGUsIENvbXBpbGVyT3BzPE91dFZhcmlhYmxlPj4ge1xuICBwcml2YXRlIHN5bWJvbFN0YWNrID0gbmV3IFN0YWNrPFN5bWJvbFRhYmxlPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3BzOiBBcnJheTxJbk9wPikge31cblxuICBwcm9jZXNzKCk6IE91dE9wW10ge1xuICAgIGxldCBvdXQ6IE91dE9wW10gPSBbXTtcbiAgICBsZXQgeyBvcHMgfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9wID0gb3BzW2ldO1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZGlzcGF0Y2gob3ApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0LnB1c2gob3AgYXMgT3V0T3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0LnB1c2gocmVzdWx0IGFzIGFueSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGRpc3BhdGNoPE8gZXh0ZW5kcyBJbk9wPihvcDogTyk6IE9wYXF1ZSB7XG4gICAgbGV0IG5hbWUgPSBvcFswXTtcbiAgICBsZXQgb3BlcmFuZCA9IG9wWzFdO1xuXG4gICAgcmV0dXJuICh0aGlzW25hbWVdIGFzIGFueSkob3BlcmFuZCk7XG4gIH1cblxuICBnZXQgc3ltYm9scygpOiBTeW1ib2xUYWJsZSB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLnN5bWJvbFN0YWNrLmN1cnJlbnQsICdFeHBlY3RlZCBhIHN5bWJvbCB0YWJsZSBvbiB0aGUgc3RhY2snKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZ3JhbShvcDogQVNULlByb2dyYW0pIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnB1c2gob3BbJ3N5bWJvbHMnXSk7XG4gIH1cblxuICBlbmRQcm9ncmFtKF9vcDogbnVsbCkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucG9wKCk7XG4gIH1cblxuICBzdGFydEJsb2NrKG9wOiBBU1QuUHJvZ3JhbSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucHVzaChvcFsnc3ltYm9scyddKTtcbiAgfVxuXG4gIGVuZEJsb2NrKF9vcDogbnVsbCkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucG9wKCk7XG4gIH1cblxuICBmbHVzaEVsZW1lbnQob3A6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucHVzaChvcFsnc3ltYm9scyddKTtcbiAgfVxuXG4gIGNsb3NlRWxlbWVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucG9wKCk7XG4gIH1cblxuICBjbG9zZUNvbXBvbmVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucG9wKCk7XG4gIH1cblxuICBjbG9zZUR5bmFtaWNDb21wb25lbnQoX29wOiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgYXR0clNwbGF0KF9vcDogT3B0aW9uPEluVmFyaWFibGU+KTogT3V0T3A8J2F0dHJTcGxhdCc+IHtcbiAgICByZXR1cm4gWydhdHRyU3BsYXQnLCB0aGlzLnN5bWJvbHMuYWxsb2NhdGVCbG9jaygnYXR0cnMnKV07XG4gIH1cblxuICBnZXQob3A6IFtJblZhcmlhYmxlLCBzdHJpbmdbXV0pOiBPdXRPcDwnZ2V0JyB8ICdtYXliZUxvY2FsJz4ge1xuICAgIGxldCBbbmFtZSwgcmVzdF0gPSBvcDtcblxuICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICByZXR1cm4gWydnZXQnLCBbMCwgcmVzdF1dO1xuICAgIH1cblxuICAgIGlmIChpc0xvY2FsKG5hbWUsIHRoaXMuc3ltYm9scykpIHtcbiAgICAgIGxldCBoZWFkID0gdGhpcy5zeW1ib2xzLmdldChuYW1lKTtcbiAgICAgIHJldHVybiBbJ2dldCcsIFtoZWFkLCByZXN0XV07XG4gICAgfSBlbHNlIGlmIChuYW1lWzBdID09PSAnQCcpIHtcbiAgICAgIGxldCBoZWFkID0gdGhpcy5zeW1ib2xzLmFsbG9jYXRlTmFtZWQobmFtZSk7XG4gICAgICByZXR1cm4gWydnZXQnLCBbaGVhZCwgcmVzdF1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWydtYXliZUxvY2FsJywgW25hbWUsIC4uLnJlc3RdXTtcbiAgICB9XG4gIH1cblxuICBtYXliZUdldChvcDogW0luVmFyaWFibGUsIHN0cmluZ1tdXSk6IE91dE9wPCdnZXQnIHwgJ3Vua25vd24nIHwgJ21heWJlTG9jYWwnPiB7XG4gICAgbGV0IFtuYW1lLCByZXN0XSA9IG9wO1xuXG4gICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgIHJldHVybiBbJ2dldCcsIFswLCByZXN0XV07XG4gICAgfVxuXG4gICAgaWYgKGlzTG9jYWwobmFtZSwgdGhpcy5zeW1ib2xzKSkge1xuICAgICAgbGV0IGhlYWQgPSB0aGlzLnN5bWJvbHMuZ2V0KG5hbWUpO1xuICAgICAgcmV0dXJuIFsnZ2V0JywgW2hlYWQsIHJlc3RdXTtcbiAgICB9IGVsc2UgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgICAgbGV0IGhlYWQgPSB0aGlzLnN5bWJvbHMuYWxsb2NhdGVOYW1lZChuYW1lKTtcbiAgICAgIHJldHVybiBbJ2dldCcsIFtoZWFkLCByZXN0XV07XG4gICAgfSBlbHNlIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFsndW5rbm93bicsIG5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWydtYXliZUxvY2FsJywgW25hbWUsIC4uLnJlc3RdXTtcbiAgICB9XG4gIH1cblxuICB5aWVsZChvcDogSW5WYXJpYWJsZSk6IE91dE9wPCd5aWVsZCc+IHtcbiAgICBpZiAob3AgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHlpZWxkIHRvIHRoaXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWyd5aWVsZCcsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKG9wKV07XG4gIH1cblxuICBkZWJ1Z2dlcihfb3A6IE9wdGlvbjxJblZhcmlhYmxlW10+KTogT3V0T3A8J2RlYnVnZ2VyJz4ge1xuICAgIHJldHVybiBbJ2RlYnVnZ2VyJywgdGhpcy5zeW1ib2xzLmdldEV2YWxJbmZvKCldO1xuICB9XG5cbiAgaGFzQmxvY2sob3A6IEluVmFyaWFibGUpOiBPdXRPcDwnaGFzQmxvY2snPiB7XG4gICAgaWYgKG9wID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXNCbG9jayB0aGlzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsnaGFzQmxvY2snLCB0aGlzLnN5bWJvbHMuYWxsb2NhdGVCbG9jayhvcCldO1xuICB9XG5cbiAgaGFzQmxvY2tQYXJhbXMob3A6IEluVmFyaWFibGUpOiBPdXRPcDwnaGFzQmxvY2tQYXJhbXMnPiB7XG4gICAgaWYgKG9wID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXNCbG9ja1BhcmFtcyB0aGlzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsnaGFzQmxvY2tQYXJhbXMnLCB0aGlzLnN5bWJvbHMuYWxsb2NhdGVCbG9jayhvcCldO1xuICB9XG5cbiAgcGFydGlhbChfb3A6IE9wdGlvbjxJblZhcmlhYmxlW10+KTogT3V0T3A8J3BhcnRpYWwnPiB7XG4gICAgcmV0dXJuIFsncGFydGlhbCcsIHRoaXMuc3ltYm9scy5nZXRFdmFsSW5mbygpXTtcbiAgfVxuXG4gIHRleHQoX29wOiBzdHJpbmcpIHt9XG4gIGNvbW1lbnQoX29wOiBzdHJpbmcpIHt9XG4gIG9wZW5Db21wb25lbnQoX29wOiBBU1QuRWxlbWVudE5vZGUpIHt9XG4gIG9wZW5FbGVtZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7fVxuICBvcGVuU3BsYXR0ZWRFbGVtZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7fVxuICBzdGF0aWNBcmcoX29wOiBzdHJpbmcpIHt9XG4gIGR5bmFtaWNBcmcoX29wOiBzdHJpbmcpIHt9XG4gIHN0YXRpY0F0dHIoX29wOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHt9XG4gIHRydXN0aW5nQXR0cihfb3A6IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge31cbiAgdHJ1c3RpbmdDb21wb25lbnRBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICBkeW5hbWljQXR0cihfb3A6IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge31cbiAgY29tcG9uZW50QXR0cihfb3A6IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge31cbiAgbW9kaWZpZXIoX29wOiBzdHJpbmcpIHt9XG4gIGFwcGVuZChfb3A6IGJvb2xlYW4pIHt9XG4gIGJsb2NrKF9vcDogW3N0cmluZywgbnVtYmVyLCBPcHRpb248bnVtYmVyPl0pIHt9XG4gIGxpdGVyYWwoX29wOiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCkge31cbiAgaGVscGVyKF9vcDogc3RyaW5nKSB7fVxuICB1bmtub3duKF9vcDogc3RyaW5nKSB7fVxuICBtYXliZUxvY2FsKF9vcDogc3RyaW5nW10pIHt9XG4gIHByZXBhcmVBcnJheShfb3A6IG51bWJlcikge31cbiAgcHJlcGFyZU9iamVjdChfb3A6IG51bWJlcikge31cbiAgY29uY2F0KF9vcDogbnVsbCkge31cbn1cblxuZnVuY3Rpb24gaXNMb2NhbChuYW1lOiBzdHJpbmcsIHN5bWJvbHM6IFN5bWJvbFRhYmxlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzeW1ib2xzICYmIHN5bWJvbHMuaGFzKG5hbWUpO1xufVxuIiwiaW1wb3J0IFRlbXBsYXRlVmlzaXRvciwgeyBBY3Rpb24gfSBmcm9tICcuL3RlbXBsYXRlLXZpc2l0b3InO1xuaW1wb3J0IEphdmFTY3JpcHRDb21waWxlciwgeyBUZW1wbGF0ZSB9IGZyb20gJy4vamF2YXNjcmlwdC1jb21waWxlcic7XG5pbXBvcnQgeyBhc3NlcnQsIE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVNULCBpc0xpdGVyYWwsIFN5bnRheEVycm9yIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IGdldEF0dHJOYW1lc3BhY2UgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IE9wYXF1ZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3ltYm9sQWxsb2NhdG9yLCBJbk9wIGFzIFN5bWJvbEluT3AsIE91dE9wIGFzIFN5bWJvbE91dE9wIH0gZnJvbSAnLi9hbGxvY2F0ZS1zeW1ib2xzJztcbmltcG9ydCB7IFBhdGhIZWFkIH0gZnJvbSAnLi9jb21waWxlci1vcHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGVPcHRpb25zIHtcbiAgbWV0YTogT3BhcXVlO1xuICBjdXN0b21pemVDb21wb25lbnROYW1lPyh0YWc6IHN0cmluZyk6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gaXNUcnVzdGVkVmFsdWUodmFsdWU6IGFueSkge1xuICByZXR1cm4gdmFsdWUuZXNjYXBlZCAhPT0gdW5kZWZpbmVkICYmICF2YWx1ZS5lc2NhcGVkO1xufVxuXG5leHBvcnQgY29uc3QgVEhJUyA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlQ29tcGlsZXIge1xuICBzdGF0aWMgY29tcGlsZShhc3Q6IEFTVC5Qcm9ncmFtLCBvcHRpb25zPzogQ29tcGlsZU9wdGlvbnMpOiBUZW1wbGF0ZSB7XG4gICAgbGV0IHRlbXBsYXRlVmlzaXRvciA9IG5ldyBUZW1wbGF0ZVZpc2l0b3IoKTtcbiAgICB0ZW1wbGF0ZVZpc2l0b3IudmlzaXQoYXN0KTtcblxuICAgIGxldCBjb21waWxlciA9IG5ldyBUZW1wbGF0ZUNvbXBpbGVyKCk7XG4gICAgbGV0IG9wY29kZXM6IFN5bWJvbEluT3BbXSA9IGNvbXBpbGVyLnByb2Nlc3ModGVtcGxhdGVWaXNpdG9yLmFjdGlvbnMpO1xuICAgIGxldCBzeW1ib2xzOiBTeW1ib2xPdXRPcFtdID0gbmV3IFN5bWJvbEFsbG9jYXRvcihvcGNvZGVzKS5wcm9jZXNzKCk7XG5cbiAgICByZXR1cm4gSmF2YVNjcmlwdENvbXBpbGVyLnByb2Nlc3Moc3ltYm9scywgYXN0WydzeW1ib2xzJ10sIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSB0ZW1wbGF0ZUlkID0gMDtcbiAgcHJpdmF0ZSB0ZW1wbGF0ZUlkczogbnVtYmVyW10gPSBbXTtcbiAgcHJpdmF0ZSBvcGNvZGVzOiBTeW1ib2xJbk9wW10gPSBbXTtcbiAgcHJpdmF0ZSBpbmNsdWRlTWV0YSA9IGZhbHNlO1xuXG4gIHByb2Nlc3MoYWN0aW9uczogQWN0aW9uW10pOiBTeW1ib2xJbk9wW10ge1xuICAgIGFjdGlvbnMuZm9yRWFjaCgoW25hbWUsIC4uLmFyZ3NdKSA9PiB7XG4gICAgICBpZiAoIXRoaXNbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmltcGxlbWVudGVkICR7bmFtZX0gb24gVGVtcGxhdGVDb21waWxlcmApO1xuICAgICAgfVxuICAgICAgKHRoaXNbbmFtZV0gYXMgYW55KSguLi5hcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5vcGNvZGVzO1xuICB9XG5cbiAgc3RhcnRQcm9ncmFtKFtwcm9ncmFtXTogW0FTVC5Qcm9ncmFtXSkge1xuICAgIHRoaXMub3Bjb2RlKFsnc3RhcnRQcm9ncmFtJywgcHJvZ3JhbV0sIHByb2dyYW0pO1xuICB9XG5cbiAgZW5kUHJvZ3JhbSgpIHtcbiAgICB0aGlzLm9wY29kZShbJ2VuZFByb2dyYW0nLCBudWxsXSwgbnVsbCk7XG4gIH1cblxuICBzdGFydEJsb2NrKFtwcm9ncmFtXTogW0FTVC5Qcm9ncmFtXSkge1xuICAgIHRoaXMudGVtcGxhdGVJZCsrO1xuICAgIHRoaXMub3Bjb2RlKFsnc3RhcnRCbG9jaycsIHByb2dyYW1dLCBwcm9ncmFtKTtcbiAgfVxuXG4gIGVuZEJsb2NrKCkge1xuICAgIHRoaXMudGVtcGxhdGVJZHMucHVzaCh0aGlzLnRlbXBsYXRlSWQgLSAxKTtcbiAgICB0aGlzLm9wY29kZShbJ2VuZEJsb2NrJywgbnVsbF0sIG51bGwpO1xuICB9XG5cbiAgdGV4dChbYWN0aW9uXTogW0FTVC5UZXh0Tm9kZV0pIHtcbiAgICB0aGlzLm9wY29kZShbJ3RleHQnLCBhY3Rpb24uY2hhcnNdLCBhY3Rpb24pO1xuICB9XG5cbiAgY29tbWVudChbYWN0aW9uXTogW0FTVC5Db21tZW50U3RhdGVtZW50XSkge1xuICAgIHRoaXMub3Bjb2RlKFsnY29tbWVudCcsIGFjdGlvbi52YWx1ZV0sIGFjdGlvbik7XG4gIH1cblxuICBvcGVuRWxlbWVudChbYWN0aW9uXTogW0FTVC5FbGVtZW50Tm9kZV0pIHtcbiAgICBsZXQgYXR0cmlidXRlcyA9IGFjdGlvbi5hdHRyaWJ1dGVzO1xuICAgIGxldCBoYXNTcGxhdCA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICBpZiAoYXR0ci5uYW1lID09PSAnLi4uYXR0cmlidXRlcycpIHtcbiAgICAgICAgaGFzU3BsYXQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYWN0aW9uSXNDb21wb25lbnQgPSBmYWxzZTtcblxuICAgIGlmIChpc0R5bmFtaWNDb21wb25lbnQoYWN0aW9uKSkge1xuICAgICAgbGV0IGhlYWQ6IFBhdGhIZWFkLCByZXN0OiBzdHJpbmdbXTtcbiAgICAgIFtoZWFkLCAuLi5yZXN0XSA9IGFjdGlvbi50YWcuc3BsaXQoJy4nKTtcbiAgICAgIGlmIChoZWFkID09PSAndGhpcycpIHtcbiAgICAgICAgaGVhZCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLm9wY29kZShbJ2dldCcsIFtoZWFkLCByZXN0XV0pO1xuICAgICAgdGhpcy5vcGNvZGUoWydvcGVuQ29tcG9uZW50JywgYWN0aW9uXSwgYWN0aW9uKTtcbiAgICAgIGFjdGlvbklzQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQ29tcG9uZW50KGFjdGlvbikpIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnb3BlbkNvbXBvbmVudCcsIGFjdGlvbl0sIGFjdGlvbik7XG4gICAgICBhY3Rpb25Jc0NvbXBvbmVudCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNTcGxhdCkge1xuICAgICAgdGhpcy5vcGNvZGUoWydvcGVuU3BsYXR0ZWRFbGVtZW50JywgYWN0aW9uXSwgYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGNvZGUoWydvcGVuRWxlbWVudCcsIGFjdGlvbl0sIGFjdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IHR5cGVBdHRyOiBPcHRpb248QVNULkF0dHJOb2RlPiA9IG51bGw7XG4gICAgbGV0IGF0dHJzID0gYWN0aW9uLmF0dHJpYnV0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGF0dHJzW2ldLm5hbWUgPT09ICd0eXBlJykge1xuICAgICAgICB0eXBlQXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXR0cmlidXRlKFthdHRyc1tpXV0sIGhhc1NwbGF0IHx8IGFjdGlvbklzQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZUF0dHIpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlKFt0eXBlQXR0cl0sIGhhc1NwbGF0IHx8IGFjdGlvbklzQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZShbJ2ZsdXNoRWxlbWVudCcsIGFjdGlvbl0sIG51bGwpO1xuICB9XG5cbiAgY2xvc2VFbGVtZW50KFthY3Rpb25dOiBbQVNULkVsZW1lbnROb2RlXSkge1xuICAgIGlmIChpc0R5bmFtaWNDb21wb25lbnQoYWN0aW9uKSkge1xuICAgICAgdGhpcy5vcGNvZGUoWydjbG9zZUR5bmFtaWNDb21wb25lbnQnLCBhY3Rpb25dLCBhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNDb21wb25lbnQoYWN0aW9uKSkge1xuICAgICAgdGhpcy5vcGNvZGUoWydjbG9zZUNvbXBvbmVudCcsIGFjdGlvbl0sIGFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24ubW9kaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9uLm1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm1vZGlmaWVyKFthY3Rpb24ubW9kaWZpZXJzW2ldXSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wY29kZShbJ2Nsb3NlRWxlbWVudCcsIGFjdGlvbl0sIGFjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnY2xvc2VFbGVtZW50JywgYWN0aW9uXSwgYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBhdHRyaWJ1dGUoW2FjdGlvbl06IFtBU1QuQXR0ck5vZGVdLCBpc0NvbXBvbmVudDogYm9vbGVhbikge1xuICAgIGxldCB7IG5hbWUsIHZhbHVlIH0gPSBhY3Rpb247XG5cbiAgICBsZXQgbmFtZXNwYWNlID0gZ2V0QXR0ck5hbWVzcGFjZShuYW1lKTtcbiAgICBsZXQgaXNTdGF0aWMgPSB0aGlzLnByZXBhcmVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSk7XG5cbiAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgLy8gQXJndW1lbnRzXG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydzdGF0aWNBcmcnLCBuYW1lXSwgYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLnZhbHVlLnR5cGUgPT09ICdNdXN0YWNoZVN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydkeW5hbWljQXJnJywgbmFtZV0sIGFjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wY29kZShbJ2R5bmFtaWNBcmcnLCBuYW1lXSwgYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlzVHJ1c3RpbmcgPSBpc1RydXN0ZWRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc1N0YXRpYyAmJiBuYW1lID09PSAnLi4uYXR0cmlidXRlcycpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydhdHRyU3BsYXQnLCBudWxsXSwgYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdGF0aWMgJiYgIWlzQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnc3RhdGljQXR0cicsIFtuYW1lLCBuYW1lc3BhY2VdXSwgYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUcnVzdGluZykge1xuICAgICAgICB0aGlzLm9wY29kZShcbiAgICAgICAgICBbaXNDb21wb25lbnQgPyAndHJ1c3RpbmdDb21wb25lbnRBdHRyJyA6ICd0cnVzdGluZ0F0dHInLCBbbmFtZSwgbmFtZXNwYWNlXV0sXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi52YWx1ZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFtpc0NvbXBvbmVudCA/ICdjb21wb25lbnRBdHRyJyA6ICdkeW5hbWljQXR0cicsIFtuYW1lLCBudWxsXV0sIGFjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wY29kZShbaXNDb21wb25lbnQgPyAnY29tcG9uZW50QXR0cicgOiAnZHluYW1pY0F0dHInLCBbbmFtZSwgbmFtZXNwYWNlXV0sIGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbW9kaWZpZXIoW2FjdGlvbl06IFtBU1QuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50XSkge1xuICAgIGFzc2VydElzU2ltcGxlUGF0aChhY3Rpb24ucGF0aCwgYWN0aW9uLmxvYywgJ21vZGlmaWVyJyk7XG5cbiAgICBsZXQge1xuICAgICAgcGF0aDogeyBwYXJ0cyB9LFxuICAgIH0gPSBhY3Rpb247XG5cbiAgICB0aGlzLnByZXBhcmVIZWxwZXIoYWN0aW9uKTtcbiAgICB0aGlzLm9wY29kZShbJ21vZGlmaWVyJywgcGFydHNbMF1dLCBhY3Rpb24pO1xuICB9XG5cbiAgbXVzdGFjaGUoW2FjdGlvbl06IFtBU1QuTXVzdGFjaGVTdGF0ZW1lbnRdKSB7XG4gICAgbGV0IHsgcGF0aCB9ID0gYWN0aW9uO1xuXG4gICAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgICAgdGhpcy5tdXN0YWNoZUV4cHJlc3Npb24oYWN0aW9uKTtcbiAgICAgIHRoaXMub3Bjb2RlKFsnYXBwZW5kJywgIWFjdGlvbi5lc2NhcGVkXSwgYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzWWllbGQocGF0aCkpIHtcbiAgICAgIGxldCB0byA9IGFzc2VydFZhbGlkWWllbGQoYWN0aW9uKTtcbiAgICAgIHRoaXMueWllbGQodG8sIGFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc1BhcnRpYWwocGF0aCkpIHtcbiAgICAgIGxldCBwYXJhbXMgPSBhc3NlcnRWYWxpZFBhcnRpYWwoYWN0aW9uKTtcbiAgICAgIHRoaXMucGFydGlhbChwYXJhbXMsIGFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc0RlYnVnZ2VyKHBhdGgpKSB7XG4gICAgICBhc3NlcnRWYWxpZERlYnVnZ2VyVXNhZ2UoYWN0aW9uKTtcbiAgICAgIHRoaXMuZGVidWdnZXIoJ2RlYnVnZ2VyJywgYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tdXN0YWNoZUV4cHJlc3Npb24oYWN0aW9uKTtcbiAgICAgIHRoaXMub3Bjb2RlKFsnYXBwZW5kJywgIWFjdGlvbi5lc2NhcGVkXSwgYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBibG9jayhbYWN0aW9uIC8qLCBpbmRleCwgY291bnQqL106IFtBU1QuQmxvY2tTdGF0ZW1lbnRdKSB7XG4gICAgdGhpcy5wcmVwYXJlSGVscGVyKGFjdGlvbik7XG4gICAgbGV0IHRlbXBsYXRlSWQgPSB0aGlzLnRlbXBsYXRlSWRzLnBvcCgpITtcbiAgICBsZXQgaW52ZXJzZUlkID0gYWN0aW9uLmludmVyc2UgPT09IG51bGwgPyBudWxsIDogdGhpcy50ZW1wbGF0ZUlkcy5wb3AoKSE7XG4gICAgdGhpcy5vcGNvZGUoWydibG9jaycsIFthY3Rpb24ucGF0aC5wYXJ0c1swXSwgdGVtcGxhdGVJZCwgaW52ZXJzZUlkXV0sIGFjdGlvbik7XG4gIH1cblxuICAvLy8gSW50ZXJuYWwgYWN0aW9ucywgbm90IGZvdW5kIGluIHRoZSBvcmlnaW5hbCBwcm9jZXNzZWQgYWN0aW9uc1xuXG4gIGFyZyhbcGF0aF06IFtBU1QuUGF0aEV4cHJlc3Npb25dKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnRzOiBbaGVhZCwgLi4ucmVzdF0sXG4gICAgfSA9IHBhdGg7XG4gICAgdGhpcy5vcGNvZGUoWydnZXQnLCBbYEAke2hlYWR9YCwgcmVzdF1dLCBwYXRoKTtcbiAgfVxuXG4gIG11c3RhY2hlRXhwcmVzc2lvbihleHByOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBwYXRoIH0gPSBleHByO1xuXG4gICAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgICAgdGhpcy5vcGNvZGUoWydsaXRlcmFsJywgcGF0aC52YWx1ZV0sIGV4cHIpO1xuICAgIH0gZWxzZSBpZiAoaXNCdWlsdEluSGVscGVyKHBhdGgpKSB7XG4gICAgICB0aGlzLmJ1aWx0SW5IZWxwZXIoZXhwciBhcyBBU1QuQ2FsbCk7XG4gICAgfSBlbHNlIGlmIChpc0FyZyhwYXRoKSkge1xuICAgICAgdGhpcy5hcmcoW3BhdGhdKTtcbiAgICB9IGVsc2UgaWYgKGlzSGVscGVySW52b2NhdGlvbihleHByKSkge1xuICAgICAgdGhpcy5wcmVwYXJlSGVscGVyKGV4cHIpO1xuICAgICAgdGhpcy5vcGNvZGUoWydoZWxwZXInLCBwYXRoLnBhcnRzWzBdXSwgZXhwcik7XG4gICAgfSBlbHNlIGlmIChwYXRoLnRoaXMpIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnZ2V0JywgWzAsIHBhdGgucGFydHNdXSwgZXhwcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbaGVhZCwgLi4ucGFydHNdID0gcGF0aC5wYXJ0cztcbiAgICAgIHRoaXMub3Bjb2RlKFsnbWF5YmVHZXQnLCBbaGVhZCwgcGFydHNdXSwgZXhwcik7XG4gICAgfVxuXG4gICAgLy8gfSBlbHNlIGlmIChpc0xvY2FsKHBhdGgsIHRoaXMuc3ltYm9scykpIHtcbiAgICAvLyAgIGxldCBbaGVhZCwgLi4ucGFydHNdID0gcGF0aC5wYXJ0cztcbiAgICAvLyAgIHRoaXMub3Bjb2RlKFsnZ2V0JywgW2hlYWQsIHBhcnRzXV0sIGV4cHIpO1xuICAgIC8vIH0gZWxzZSBpZiAoaXNTaW1wbGVQYXRoKHBhdGgpKSB7XG4gICAgLy8gICB0aGlzLm9wY29kZShbJ3Vua25vd24nLCBwYXRoLnBhcnRzWzBdXSwgZXhwcik7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIHRoaXMub3Bjb2RlKFsnbWF5YmVMb2NhbCcsIHBhdGgucGFydHNdLCBleHByKTtcbiAgICAvLyB9XG4gIH1cblxuICAvLy8gSW50ZXJuYWwgU3ludGF4XG5cbiAgeWllbGQodG86IHN0cmluZywgYWN0aW9uOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnByZXBhcmVQYXJhbXMoYWN0aW9uLnBhcmFtcyk7XG4gICAgdGhpcy5vcGNvZGUoWyd5aWVsZCcsIHRvXSwgYWN0aW9uKTtcbiAgfVxuXG4gIGRlYnVnZ2VyKF9uYW1lOiBzdHJpbmcsIGFjdGlvbjogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gICAgdGhpcy5vcGNvZGUoWydkZWJ1Z2dlcicsIG51bGxdLCBhY3Rpb24pO1xuICB9XG5cbiAgaGFzQmxvY2sobmFtZTogc3RyaW5nLCBhY3Rpb246IEFTVC5DYWxsKSB7XG4gICAgdGhpcy5vcGNvZGUoWydoYXNCbG9jaycsIG5hbWVdLCBhY3Rpb24pO1xuICB9XG5cbiAgaGFzQmxvY2tQYXJhbXMobmFtZTogc3RyaW5nLCBhY3Rpb246IEFTVC5DYWxsKSB7XG4gICAgdGhpcy5vcGNvZGUoWydoYXNCbG9ja1BhcmFtcycsIG5hbWVdLCBhY3Rpb24pO1xuICB9XG5cbiAgcGFydGlhbChfcGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdLCBhY3Rpb246IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIHRoaXMucHJlcGFyZVBhcmFtcyhhY3Rpb24ucGFyYW1zKTtcbiAgICB0aGlzLm9wY29kZShbJ3BhcnRpYWwnLCBudWxsXSwgYWN0aW9uKTtcbiAgfVxuXG4gIGJ1aWx0SW5IZWxwZXIoZXhwcjogQVNULkNhbGwpIHtcbiAgICBsZXQgeyBwYXRoIH0gPSBleHByO1xuICAgIGlmIChpc0hhc0Jsb2NrKHBhdGgpKSB7XG4gICAgICBsZXQgbmFtZSA9IGFzc2VydFZhbGlkSGFzQmxvY2tVc2FnZShleHByLnBhdGgub3JpZ2luYWwsIGV4cHIpO1xuICAgICAgdGhpcy5oYXNCbG9jayhuYW1lLCBleHByKTtcbiAgICB9IGVsc2UgaWYgKGlzSGFzQmxvY2tQYXJhbXMocGF0aCkpIHtcbiAgICAgIGxldCBuYW1lID0gYXNzZXJ0VmFsaWRIYXNCbG9ja1VzYWdlKGV4cHIucGF0aC5vcmlnaW5hbCwgZXhwcik7XG4gICAgICB0aGlzLmhhc0Jsb2NrUGFyYW1zKG5hbWUsIGV4cHIpO1xuICAgIH1cbiAgfVxuXG4gIC8vLyBFeHByZXNzaW9ucywgaW52b2tlZCByZWN1cnNpdmVseSBmcm9tIHByZXBhcmVQYXJhbXMgYW5kIHByZXBhcmVIYXNoXG5cbiAgU3ViRXhwcmVzc2lvbihleHByOiBBU1QuU3ViRXhwcmVzc2lvbikge1xuICAgIGlmIChpc0J1aWx0SW5IZWxwZXIoZXhwci5wYXRoKSkge1xuICAgICAgdGhpcy5idWlsdEluSGVscGVyKGV4cHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXBhcmVIZWxwZXIoZXhwcik7XG4gICAgICB0aGlzLm9wY29kZShbJ2hlbHBlcicsIGV4cHIucGF0aC5wYXJ0c1swXV0sIGV4cHIpO1xuICAgIH1cbiAgfVxuXG4gIFBhdGhFeHByZXNzaW9uKGV4cHI6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICAgIGlmIChleHByLmRhdGEpIHtcbiAgICAgIHRoaXMuYXJnKFtleHByXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbaGVhZCwgLi4ucmVzdF0gPSBleHByLnBhcnRzO1xuXG4gICAgICBpZiAoZXhwci50aGlzKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnZ2V0JywgWzAsIGV4cHIucGFydHNdXSwgZXhwcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wY29kZShbJ2dldCcsIFtoZWFkLCByZXN0XV0sIGV4cHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFN0cmluZ0xpdGVyYWwoYWN0aW9uOiBBU1QuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIGFjdGlvbi52YWx1ZV0sIGFjdGlvbik7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChhY3Rpb246IEFTVC5Cb29sZWFuTGl0ZXJhbCkge1xuICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIGFjdGlvbi52YWx1ZV0sIGFjdGlvbik7XG4gIH1cblxuICBOdW1iZXJMaXRlcmFsKGFjdGlvbjogQVNULk51bWJlckxpdGVyYWwpIHtcbiAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBhY3Rpb24udmFsdWVdLCBhY3Rpb24pO1xuICB9XG5cbiAgTnVsbExpdGVyYWwoYWN0aW9uOiBBU1QuTnVsbExpdGVyYWwpIHtcbiAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBhY3Rpb24udmFsdWVdLCBhY3Rpb24pO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbChhY3Rpb246IEFTVC5VbmRlZmluZWRMaXRlcmFsKSB7XG4gICAgdGhpcy5vcGNvZGUoWydsaXRlcmFsJywgYWN0aW9uLnZhbHVlXSwgYWN0aW9uKTtcbiAgfVxuXG4gIC8vLyBVdGlsaXRpZXNcblxuICBvcGNvZGU8TyBleHRlbmRzIFN5bWJvbEluT3A+KG9wY29kZTogTywgYWN0aW9uOiBPcHRpb248QVNULkJhc2VOb2RlPiA9IG51bGwpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgcmVhbGx5IHdvcmtcbiAgICBpZiAodGhpcy5pbmNsdWRlTWV0YSAmJiBhY3Rpb24pIHtcbiAgICAgIChvcGNvZGUgYXMgYW55KS5wdXNoKHRoaXMubWV0YShhY3Rpb24pKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZXMucHVzaChvcGNvZGUpO1xuICB9XG5cbiAgcHJlcGFyZUhlbHBlcihleHByOiBBU1QuQ2FsbCkge1xuICAgIGFzc2VydElzU2ltcGxlUGF0aChleHByLnBhdGgsIGV4cHIubG9jLCAnaGVscGVyJyk7XG5cbiAgICBsZXQgeyBwYXJhbXMsIGhhc2ggfSA9IGV4cHI7XG5cbiAgICB0aGlzLnByZXBhcmVIYXNoKGhhc2gpO1xuICAgIHRoaXMucHJlcGFyZVBhcmFtcyhwYXJhbXMpO1xuICB9XG5cbiAgcHJlcGFyZVBhcmFtcyhwYXJhbXM6IEFTVC5FeHByZXNzaW9uW10pIHtcbiAgICBpZiAoIXBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIG51bGxdLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gcGFyYW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgcGFyYW0gPSBwYXJhbXNbaV07XG5cbiAgICAgIGFzc2VydCh0aGlzW3BhcmFtLnR5cGVdLCBgVW5pbXBsZW1lbnRlZCAke3BhcmFtLnR5cGV9IG9uIFRlbXBsYXRlQ29tcGlsZXJgKTtcbiAgICAgICh0aGlzW3BhcmFtLnR5cGVdIGFzIGFueSkocGFyYW0pO1xuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKFsncHJlcGFyZUFycmF5JywgcGFyYW1zLmxlbmd0aF0sIG51bGwpO1xuICB9XG5cbiAgcHJlcGFyZUhhc2goaGFzaDogQVNULkhhc2gpIHtcbiAgICBsZXQgcGFpcnMgPSBoYXNoLnBhaXJzO1xuXG4gICAgaWYgKCFwYWlycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIG51bGxdLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gcGFpcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHBhaXJzW2ldO1xuXG4gICAgICBhc3NlcnQodGhpc1t2YWx1ZS50eXBlXSwgYFVuaW1wbGVtZW50ZWQgJHt2YWx1ZS50eXBlfSBvbiBUZW1wbGF0ZUNvbXBpbGVyYCk7XG4gICAgICAodGhpc1t2YWx1ZS50eXBlXSBhcyBhbnkpKHZhbHVlKTtcbiAgICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIGtleV0sIG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKFsncHJlcGFyZU9iamVjdCcsIHBhaXJzLmxlbmd0aF0sIG51bGwpO1xuICB9XG5cbiAgcHJlcGFyZUF0dHJpYnV0ZVZhbHVlKHZhbHVlOiBBU1QuQXR0ck5vZGVbJ3ZhbHVlJ10pIHtcbiAgICAvLyByZXR1cm5zIHRoZSBzdGF0aWMgdmFsdWUgaWYgdGhlIHZhbHVlIGlzIHN0YXRpY1xuXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdUZXh0Tm9kZSc6XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIHZhbHVlLmNoYXJzXSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ011c3RhY2hlU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVNdXN0YWNoZShbdmFsdWVdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSAnQ29uY2F0U3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5wcmVwYXJlQ29uY2F0UGFydHModmFsdWUucGFydHMpO1xuICAgICAgICB0aGlzLm9wY29kZShbJ2NvbmNhdCcsIG51bGxdLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlQ29uY2F0UGFydHMocGFydHM6IEFTVC5Db25jYXRTdGF0ZW1lbnRbJ3BhcnRzJ10pIHtcbiAgICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdNdXN0YWNoZVN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVNdXN0YWNoZShbcGFydF0pO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09ICdUZXh0Tm9kZScpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydsaXRlcmFsJywgcGFydC5jaGFyc10sIG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKFsncHJlcGFyZUFycmF5JywgcGFydHMubGVuZ3RoXSwgbnVsbCk7XG4gIH1cblxuICBhdHRyaWJ1dGVNdXN0YWNoZShbYWN0aW9uXTogW0FTVC5NdXN0YWNoZVN0YXRlbWVudF0pIHtcbiAgICB0aGlzLm11c3RhY2hlRXhwcmVzc2lvbihhY3Rpb24pO1xuICB9XG5cbiAgbWV0YShub2RlOiBBU1QuQmFzZU5vZGUpIHtcbiAgICBsZXQgbG9jID0gbm9kZS5sb2M7XG4gICAgaWYgKCFsb2MpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzb3VyY2UsIHN0YXJ0LCBlbmQgfSA9IGxvYztcbiAgICByZXR1cm4gWydsb2MnLCBbc291cmNlIHx8IG51bGwsIFtzdGFydC5saW5lLCBzdGFydC5jb2x1bW5dLCBbZW5kLmxpbmUsIGVuZC5jb2x1bW5dXV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIZWxwZXJJbnZvY2F0aW9uKFxuICBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50XG4pOiBtdXN0YWNoZSBpcyBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgJiB7IHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbiB9IHtcbiAgcmV0dXJuIChcbiAgICAobXVzdGFjaGUucGFyYW1zICYmIG11c3RhY2hlLnBhcmFtcy5sZW5ndGggPiAwKSB8fFxuICAgIChtdXN0YWNoZS5oYXNoICYmIG11c3RhY2hlLmhhc2gucGFpcnMubGVuZ3RoID4gMClcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKHsgcGFydHMgfTogQVNULlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDE7XG59XG5cbmZ1bmN0aW9uIGlzWWllbGQocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAneWllbGQnO1xufVxuXG5mdW5jdGlvbiBpc1BhcnRpYWwocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAncGFydGlhbCc7XG59XG5cbmZ1bmN0aW9uIGlzRGVidWdnZXIocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAnZGVidWdnZXInO1xufVxuXG5mdW5jdGlvbiBpc0hhc0Jsb2NrKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICByZXR1cm4gcGF0aC5vcmlnaW5hbCA9PT0gJ2hhcy1ibG9jayc7XG59XG5cbmZ1bmN0aW9uIGlzSGFzQmxvY2tQYXJhbXMocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAnaGFzLWJsb2NrLXBhcmFtcyc7XG59XG5cbmZ1bmN0aW9uIGlzQnVpbHRJbkhlbHBlcihwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24pIHtcbiAgcmV0dXJuIGlzSGFzQmxvY2socGF0aCkgfHwgaXNIYXNCbG9ja1BhcmFtcyhwYXRoKTtcbn1cblxuZnVuY3Rpb24gaXNBcmcocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIXBhdGhbJ2RhdGEnXTtcbn1cblxuZnVuY3Rpb24gaXNEeW5hbWljQ29tcG9uZW50KGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSk6IGJvb2xlYW4ge1xuICBsZXQgb3BlbiA9IGVsZW1lbnQudGFnLmNoYXJBdCgwKTtcblxuICBsZXQgW21heWJlTG9jYWxdID0gZWxlbWVudC50YWcuc3BsaXQoJy4nKTtcbiAgbGV0IGlzTmFtZWRBcmd1bWVudCA9IG9wZW4gPT09ICdAJztcbiAgbGV0IGlzTG9jYWwgPSBlbGVtZW50WydzeW1ib2xzJ10uaGFzKG1heWJlTG9jYWwpO1xuICBsZXQgaXNUaGlzUGF0aCA9IGVsZW1lbnQudGFnLmluZGV4T2YoJ3RoaXMuJykgPT09IDA7XG5cbiAgcmV0dXJuIGlzTG9jYWwgfHwgaXNOYW1lZEFyZ3VtZW50IHx8IGlzVGhpc1BhdGg7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcG9uZW50KGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSk6IGJvb2xlYW4ge1xuICBsZXQgb3BlbiA9IGVsZW1lbnQudGFnLmNoYXJBdCgwKTtcbiAgbGV0IGlzUGF0aCA9IGVsZW1lbnQudGFnLmluZGV4T2YoJy4nKSA+IC0xO1xuXG4gIGxldCBpc1VwcGVyQ2FzZSA9IG9wZW4gPT09IG9wZW4udG9VcHBlckNhc2UoKSAmJiBvcGVuICE9PSBvcGVuLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIChpc1VwcGVyQ2FzZSAmJiAhaXNQYXRoKSB8fCBpc0R5bmFtaWNDb21wb25lbnQoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzU2ltcGxlUGF0aChwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24sIGxvYzogQVNULlNvdXJjZUxvY2F0aW9uLCBjb250ZXh0OiBzdHJpbmcpIHtcbiAgaWYgKCFpc1NpbXBsZVBhdGgocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgXFxgJHtwYXRoLm9yaWdpbmFsfVxcYCBpcyBub3QgYSB2YWxpZCBuYW1lIGZvciBhICR7Y29udGV4dH0gb24gbGluZSAke2xvYy5zdGFydC5saW5lfS5gLFxuICAgICAgcGF0aC5sb2NcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkWWllbGQoc3RhdGVtZW50OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpOiBzdHJpbmcge1xuICBsZXQgeyBwYWlycyB9ID0gc3RhdGVtZW50Lmhhc2g7XG5cbiAgaWYgKChwYWlycy5sZW5ndGggPT09IDEgJiYgcGFpcnNbMF0ua2V5ICE9PSAndG8nKSB8fCBwYWlycy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGB5aWVsZCBvbmx5IHRha2VzIGEgc2luZ2xlIG5hbWVkIGFyZ3VtZW50OiAndG8nYCwgc3RhdGVtZW50LmxvYyk7XG4gIH0gZWxzZSBpZiAocGFpcnMubGVuZ3RoID09PSAxICYmIHBhaXJzWzBdLnZhbHVlLnR5cGUgIT09ICdTdHJpbmdMaXRlcmFsJykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgeW91IGNhbiBvbmx5IHlpZWxkIHRvIGEgbGl0ZXJhbCB2YWx1ZWAsIHN0YXRlbWVudC5sb2MpO1xuICB9IGVsc2UgaWYgKHBhaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnZGVmYXVsdCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChwYWlyc1swXS52YWx1ZSBhcyBBU1QuU3RyaW5nTGl0ZXJhbCkudmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQYXJ0aWFsKHN0YXRlbWVudDogQVNULk11c3RhY2hlU3RhdGVtZW50KSAvKiA6IGV4cHIgKi8ge1xuICBsZXQgeyBwYXJhbXMsIGhhc2gsIGVzY2FwZWQsIGxvYyB9ID0gc3RhdGVtZW50O1xuXG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBQYXJ0aWFsIGZvdW5kIHdpdGggbm8gYXJndW1lbnRzLiBZb3UgbXVzdCBzcGVjaWZ5IGEgdGVtcGxhdGUgbmFtZS4gKG9uIGxpbmUgJHtcbiAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgIH0pYCxcbiAgICAgIHN0YXRlbWVudC5sb2NcbiAgICApO1xuICB9IGVsc2UgaWYgKGhhc2ggJiYgaGFzaC5wYWlycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYHBhcnRpYWwgZG9lcyBub3QgdGFrZSBhbnkgbmFtZWQgYXJndW1lbnRzIChvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9KWAsXG4gICAgICBzdGF0ZW1lbnQubG9jXG4gICAgKTtcbiAgfSBlbHNlIGlmICghZXNjYXBlZCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGB7e3twYXJ0aWFsIC4uLn19fSBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2UgdXNlIHt7cGFydGlhbCAuLi59fSBpbnN0ZWFkIChvbiBsaW5lICR7XG4gICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICB9KWAsXG4gICAgICBzdGF0ZW1lbnQubG9jXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkSGFzQmxvY2tVc2FnZSh0eXBlOiBzdHJpbmcsIGNhbGw6IEFTVC5DYWxsKTogc3RyaW5nIHtcbiAgbGV0IHsgcGFyYW1zLCBoYXNoLCBsb2MgfSA9IGNhbGw7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5wYWlycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGAke3R5cGV9IGRvZXMgbm90IHRha2UgYW55IG5hbWVkIGFyZ3VtZW50c2AsIGNhbGwubG9jKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0JztcbiAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgbGV0IHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICAgIHJldHVybiBwYXJhbS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBgeW91IGNhbiBvbmx5IHlpZWxkIHRvIGEgbGl0ZXJhbCB2YWx1ZSAob24gbGluZSAke2xvYy5zdGFydC5saW5lfSlgLFxuICAgICAgICBjYWxsLmxvY1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYCR7dHlwZX0gb25seSB0YWtlcyBhIHNpbmdsZSBwb3NpdGlvbmFsIGFyZ3VtZW50IChvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9KWAsXG4gICAgICBjYWxsLmxvY1xuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWREZWJ1Z2dlclVzYWdlKHN0YXRlbWVudDogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gIGxldCB7IHBhcmFtcywgaGFzaCB9ID0gc3RhdGVtZW50O1xuXG4gIGlmIChoYXNoICYmIGhhc2gucGFpcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgZGVidWdnZXIgZG9lcyBub3QgdGFrZSBhbnkgbmFtZWQgYXJndW1lbnRzYCwgc3RhdGVtZW50LmxvYyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnZGVmYXVsdCc7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBkZWJ1Z2dlciBkb2VzIG5vdCB0YWtlIGFueSBwb3NpdGlvbmFsIGFyZ3VtZW50c2AsIHN0YXRlbWVudC5sb2MpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBwcmVwcm9jZXNzIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCBUZW1wbGF0ZUNvbXBpbGVyLCB7IENvbXBpbGVPcHRpb25zIH0gZnJvbSAnLi90ZW1wbGF0ZS1jb21waWxlcic7XG5pbXBvcnQge1xuICBTZXJpYWxpemVkVGVtcGxhdGVXaXRoTGF6eUJsb2NrLFxuICBUZW1wbGF0ZUphdmFzY3JpcHQsXG4gIFRlbXBsYXRlTWV0YSxcbn0gZnJvbSAnQGdsaW1tZXIvd2lyZS1mb3JtYXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQcmVwcm9jZXNzT3B0aW9ucyB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVJZEZuIHtcbiAgKHNyYzogc3RyaW5nKTogT3B0aW9uPHN0cmluZz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlY29tcGlsZU9wdGlvbnMgZXh0ZW5kcyBDb21waWxlT3B0aW9ucywgUHJlcHJvY2Vzc09wdGlvbnMge1xuICBpZD86IFRlbXBsYXRlSWRGbjtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiByZXF1aXJlKGlkOiBzdHJpbmcpOiBhbnk7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0SWQ6IFRlbXBsYXRlSWRGbiA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1yZXF1aXJlLWltcG9ydHMgKi9cbiAgICAgIGNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1yZXF1aXJlLWltcG9ydHMgKi9cblxuICAgICAgbGV0IGlkRm46IFRlbXBsYXRlSWRGbiA9IHNyYyA9PiB7XG4gICAgICAgIGxldCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICAgICAgaGFzaC51cGRhdGUoc3JjLCAndXRmOCcpO1xuICAgICAgICAvLyB0cmltIHRvIDYgYnl0ZXMgb2YgZGF0YSAoMl40OCAtIDEpXG4gICAgICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnYmFzZTY0Jykuc3Vic3RyaW5nKDAsIDgpO1xuICAgICAgfTtcblxuICAgICAgaWRGbigndGVzdCcpO1xuXG4gICAgICByZXR1cm4gaWRGbjtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGlkRm4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59KSgpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogUHJlY29tcGlsZU9wdGlvbnMgPSB7XG4gIGlkOiBkZWZhdWx0SWQsXG4gIG1ldGE6IHt9LFxufTtcblxuLypcbiAqIENvbXBpbGUgYSBzdHJpbmcgaW50byBhIHRlbXBsYXRlIGphdmFzY3JpcHQgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiAgICAgaW1wb3J0IHsgcHJlY29tcGlsZSB9IGZyb20gJ0BnbGltbWVyL2NvbXBpbGVyJztcbiAqICAgICBpbXBvcnQgeyB0ZW1wbGF0ZUZhY3RvcnkgfSBmcm9tICdnbGltZXItcnVudGltZSc7XG4gKiAgICAgbGV0IHRlbXBsYXRlSnMgPSBwcmVjb21waWxlKFwiSG93ZHkge3tuYW1lfX1cIik7XG4gKiAgICAgbGV0IGZhY3RvcnkgPSB0ZW1wbGF0ZUZhY3RvcnkobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgdGVtcGxhdGVKcykoKSk7XG4gKiAgICAgbGV0IHRlbXBsYXRlID0gZmFjdG9yeS5jcmVhdGUoZW52KTtcbiAqXG4gKiBAbWV0aG9kIHByZWNvbXBpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgYSBHbGltbWVyIHRlbXBsYXRlIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBhIHRlbXBsYXRlIGphdmFzY3JpcHQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVjb21waWxlKHN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUHJlY29tcGlsZU9wdGlvbnMpOiBUZW1wbGF0ZUphdmFzY3JpcHQ7XG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcGlsZShcbiAgc3RyaW5nOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFByZWNvbXBpbGVPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbik6IFRlbXBsYXRlSmF2YXNjcmlwdCB7XG4gIGxldCBhc3QgPSBwcmVwcm9jZXNzKHN0cmluZywgb3B0aW9ucyk7XG4gIGxldCB7IG1ldGEgfSA9IG9wdGlvbnM7XG4gIGxldCB7IGJsb2NrIH0gPSBUZW1wbGF0ZUNvbXBpbGVyLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbiAgbGV0IGlkRm4gPSBvcHRpb25zLmlkIHx8IGRlZmF1bHRJZDtcbiAgbGV0IGJsb2NrSlNPTiA9IEpTT04uc3RyaW5naWZ5KGJsb2NrLnRvSlNPTigpKTtcbiAgbGV0IHRlbXBsYXRlSlNPTk9iamVjdDogU2VyaWFsaXplZFRlbXBsYXRlV2l0aExhenlCbG9jazxUZW1wbGF0ZU1ldGE+ID0ge1xuICAgIGlkOiBpZEZuKEpTT04uc3RyaW5naWZ5KG1ldGEpICsgYmxvY2tKU09OKSxcbiAgICBibG9jazogYmxvY2tKU09OLFxuICAgIG1ldGE6IG1ldGEgYXMgVGVtcGxhdGVNZXRhLFxuICB9O1xuXG4gIC8vIEpTT04gaXMgamF2YXNjcmlwdFxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGVtcGxhdGVKU09OT2JqZWN0KTtcbn1cbiJdLCJuYW1lcyI6WyJkaWN0IiwidW5yZWFjaGFibGUiLCJEaWN0U2V0IiwiaXNGbHVzaEVsZW1lbnQiLCJpc0FyZ3VtZW50IiwiaXNBdHRyaWJ1dGUiLCJTdGFjayIsIk9wcyIsImlzTGl0ZXJhbCIsIlN5bnRheEVycm9yIiwicHJlcHJvY2VzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsSUFFc0I7Ozs7O2dCQUNiLHFCQUNMO2VBQU8sSUFBSTs7O2lEQWFQOzs7WUFDQSxpQkFBaUI7bUJBQVksTUFBSyxTQUFTO1NB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