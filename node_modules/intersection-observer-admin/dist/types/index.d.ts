declare type IndividualEntry = {
    element?: HTMLElement | Window;
    enterCallback?: Function;
    exitCallback?: Function;
};
export interface IObserverOption {
    root?: HTMLElement;
    rootMargin?: string;
    threshold?: number;
    [key: string]: any;
}
declare type RootEntry = {
    elements: [IndividualEntry];
    observerOptions: IObserverOption;
    intersectionObserver: any;
};
declare type PotentialRootEntry = {
    [stringifiedOptions: string]: RootEntry;
};
export default class IntersectionObserverAdmin {
    private DOMRef;
    constructor();
    /**
     * Adds element to observe via IntersectionObserver and stores element + relevant callbacks and observer options in static
     * administrator for lookup in the future
     *
     * @method add
     * @param {HTMLElement | Window} element
     * @param {Function} enterCallback
     * @param {Function} exitCallback
     * @param {Object} observerOptions
     * @param {String} scrollableArea
     * @public
     */
    observe(element: HTMLElement, enterCallback: Function, exitCallback: Function, observerOptions?: IObserverOption, scrollableArea?: string): void;
    /**
     * Unobserve target element and remove element from static admin
     *
     * @method unobserve
     * @param {HTMLElement|Window} target
     * @param {Object} observerOptions
     * @param {String} scrollableArea
     * @public
     */
    unobserve(target: HTMLElement, observerOptions: IObserverOption, scrollableArea: string): void;
    /**
     * cleanup data structures and unobserve elements
     *
     * @method destroy
     * @public
     */
    destroy(): void;
    /**
     * use function composition to curry observerOptions
     *
     * @method _setupOnIntersection
     * @param {Object} observerOptions
     * @param {String} scrollableArea
     */
    protected _setupOnIntersection(observerOptions: IObserverOption, scrollableArea: string | undefined): Function;
    /**
     * IntersectionObserver callback when element is intersecting viewport
     *
     * @method _onIntersection
     * @param {Object} observerOptions
     * @param {String} scrollableArea
     * @param {Array} ioEntries
     * @private
     */
    protected _onIntersection(observerOptions: IObserverOption, scrollableArea: string | undefined, ioEntries: Array<any>): void;
    /**
     * { root: { stringifiedOptions: { elements: []...] } }
     * @method _findRoot
     * @param {HTMLElement|Window} root
     * @private
     * @return {Object} of elements that share same root
     */
    protected _findRoot(root: HTMLElement | Window): PotentialRootEntry | null | undefined;
    /**
     * Used for onIntersection callbacks and unobserving the IntersectionObserver
     * We don't care about observerOptions key order because we already added
     * to the static administrator or found an existing IntersectionObserver with the same
     * root && observerOptions to reuse
     *
     * @method _findMatchingRootEntry
     * @param {Object} observerOptions
     * @param {String} scrollableArea
     * @return {Object} entry with elements and other options
     */
    protected _findMatchingRootEntry(observerOptions: IObserverOption, scrollableArea: string | undefined): RootEntry | undefined;
    /**
     * Determine if existing elements for a given root based on passed in observerOptions
     * regardless of sort order of keys
     *
     * @method _determineMatchingElements
     * @param {Object} observerOptions
     * @param {Object} potentialRootMatch e.g. { stringifiedOptions: { elements: [], ... }, stringifiedOptions: { elements: [], ... }}
     * @private
     * @return {Object} containing array of elements and other meta
     */
    protected _determineMatchingElements(observerOptions: IObserverOption, potentialRootMatch?: PotentialRootEntry): RootEntry | undefined;
    /**
     * recursive method to test primitive string, number, null, etc and complex
     * object equality.
     *
     * @method _areOptionsSame
     * @param {Object} observerOptions
     * @param {Object} comparableOptions
     * @private
     * @return {Boolean}
     */
    protected _areOptionsSame(observerOptions: IObserverOption, comparableOptions: IObserverOption): boolean;
    /**
     * Stringify observerOptions for use as a key.
     * Excludes observerOptions.root so that the resulting key is stable
     *
     * @param {Object} observerOptions
     * @param {String} scrollableArea
     * @private
     * @return {String}
     */
    protected _stringifyObserverOptions(observerOptions: IObserverOption, scrollableArea: string | undefined): string;
}
export {};
